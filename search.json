[{"title":"每日学习笔记(2018.8.24)","url":"https://yixiaoer.github.io/2018/08/24/日常学习笔记(2018.8.24)/","content":"<p><strong>每日学习笔记</strong><br>Web学习相关内容<br>大部分都只是所看的记录<br><em>2018.8.24</em> 《Go Web》安全之前部分;redis安装及简单语法</p>\n<h1 id=\"《Go-Web》\"><a href=\"#《Go-Web》\" class=\"headerlink\" title=\"《Go Web》\"></a>《Go Web》</h1><h2 id=\"Web服务\"><a href=\"#Web服务\" class=\"headerlink\" title=\"Web服务\"></a>Web服务</h2><ul>\n<li><p>socket编程</p>\n<ul>\n<li><p>套接字</p>\n</li>\n<li><p>在本地可以通过进程PID来唯一标识一个进程,但在网络中是行不通的,其实TCP/IP协议族已经解决了这个问题,网络层的”ip地址”可以唯一标识网络中的主机,而传输层的“协议+端口”可以唯一标识主机中的应用程序(进程),这样利用三元组(ip地址,协议,端口)就可以标识网络的进程,网络中需要互相通信的进程,可以利用这个标志在他们之间进行交互</p>\n</li>\n<li><p>一种操作系统提供的进程间通信机制,在操作系统中,通常会为应用程序提供一组应用程序接口(API),称为<strong>套接字接口</strong>(socket API)。应用程序可以通过套接字接口,来使用网络套接字,以进行数据交换</p>\n</li>\n<li><p>socket是在应用层和传输层之间的一个抽象层,它把TCP/IP层复杂的操作抽象为几个简单的接口供应用层调用已实现进程在网络中通信</p>\n</li>\n<li><p>起源于UNIX,在Unix一切皆文件哲学的思想下,socket是一种”打开➡️读/写➡️关闭”模式的实现,服务器和客户端各自维护一个”文件”,在建立连接打开后,可以向自己文件写入内容供对方读取或者读取对方内容,通讯结束时关闭文件</p>\n</li>\n<li><p>TCP/IP是socket的一种实现,socket是对TCP/IP协议的封装,Socket本身并不是协议,而是一个调用接口(API)通过Socket,才能使用TCP/IP协议,Socket跟TCP/IP协议没有必然的联系,Socket编程接口在设计的时候,就希望也能适应其他的网络协议</p>\n</li>\n<li><p>Socket的出现只是使得TCP/IP协议栈更方便地使用,它是对TCP/IP协议的抽,从而形成了一些最基本的函数接口(eg.create,listen,connect,accept,send,read,write,etc.)</p>\n<p>关于<a href=\"http://lib.csdn.net/article/computernetworks/20534\" target=\"_blank\" rel=\"noopener\">TCP/IP、Http、Socket的区别</a></p>\n</li>\n<li><p>流程</p>\n<p>建立Socket连接至少需要一对套接字,其中一个运行于客户端,称为ClientSocket ;另一个运行于服务器端,称为ServerSocket</p>\n<p>套接字之间的连接过程分为三个步骤:</p>\n<ul>\n<li><strong>服务器监听</strong>:服务器端套接字并不定位具体的客户端套接字,而是处于等待连接的状态,实时监控网络状态,等待客户端的连接请求</li>\n<li><strong>客户端请求</strong>:客户端的套接字提出连接请求,要连接的目标是服务器端的套接字。为此,客户端的套接字必须首先描述它要连接的服务器的套接字,指出服务器端套接字的地址和端口号,然后就向服务器端套接字提出连接请求</li>\n<li><strong>连接确认</strong>:当服务器端套接字监听到或者说接收到客户端套接字的连接请求时,就响应客户端套接字的请求,建立一个新的线程,把服务器端套接字的描述发给客户端,一旦客户端确认了此描述,双方就正式建立连接。而服务器端套接字继续处于监听状态,继续接收其他客户端套接字的连接请求</li>\n</ul>\n</li>\n<li><p>关于TCP连接的三次握手</p>\n<p>第一次握手：客户端尝试连接服务器，向服务器发送syn包（同步序列编号<strong>*Synchronize Sequence Numbers*</strong>），syn=j，客户端进入SYN_SEND状态等待服务器确认</p>\n<p>第二次握手：服务器接收客户端syn包并确认（ack=j+1），同时向客户端发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态</p>\n<p>第三次握手：第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1），此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手</p>\n</li>\n<li><p>两种socket</p>\n<p>TCP和UDP是协议,而要确定一个进程的需要三元组,IP地址和端口</p>\n<ul>\n<li>TCP Socket</li>\n<li>UDP Socke</li>\n</ul>\n</li>\n<li><p>Go语言中</p>\n<ul>\n<li><p>在Go的<code>net</code>包中定义了很多类型、函数和方法用来网络编程，其中IP的定义如下：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> IP []<span class=\"keyword\">byte</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p><code>ParseIP(s string) IP</code>函数会把一个IPv4或者IPv6的地址转化成IP类型</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">    <span class=\"string\">\"net\"</span></span><br><span class=\"line\">    <span class=\"string\">\"os\"</span></span><br><span class=\"line\">    <span class=\"string\">\"fmt\"</span></span><br><span class=\"line\">)</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"built_in\">len</span>(os.Args) != <span class=\"number\">2</span> &#123;</span><br><span class=\"line\">        fmt.Fprintf(os.Stderr, <span class=\"string\">\"Usage: %s ip-addr\\n\"</span>, os.Args[<span class=\"number\">0</span>])</span><br><span class=\"line\">        <span class=\"comment\">//os可以通过变量Args来获取命令参数，os.Args返回一个字符串数组，其中第一个参数就是执行文件本身</span></span><br><span class=\"line\">        os.Exit(<span class=\"number\">1</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    name := os.Args[<span class=\"number\">1</span>]</span><br><span class=\"line\">    addr := net.ParseIP(name)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> addr == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        fmt.Println(<span class=\"string\">\"Invalid address\"</span>)</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        fmt.Println(<span class=\"string\">\"The address is \"</span>, addr.String())</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    os.Exit(<span class=\"number\">0</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>REST</p>\n<ul>\n<li><p>REpresentational State Transfer</p>\n<ul>\n<li><strong>资源(Resources)</strong>:REST是”表现层状态转化”,其实它省略了主语,表现层”其实指的是”资源”的”表现层”。资源是上网访问的一张图片、一个文档、一个视频等。这些资源通过URI来定位,也就是一个URI表示一个资源</li>\n<li><strong>表现层(Representation)</strong>:资源是做一个具体的实体信息,可有多种展现方式。而把实体展现出来就是表现层(eg.一个txt文本信息,输出成html、json、xml等格式;一个图片以jpg、png等方式展现)。URI确定一个资源,确定它的具体表现形式应在HTTP请求的头信息中用Accept和Content-Type字段指定,这两个字段是对”表现层”的描述</li>\n<li><strong>状态转化(State Transfer)</strong>:访问一个网站,就代表了客户端和服务器的一个互动过程。在这个过程中,涉及到数据和状态的变化,而HTTP协议是无状态的,则这些状态保存在服务器端,所以如果客户端想要通知服务器端改变数据和状态的变化,需要通过某种方式来通知,客户端能通知服务器端的手段,只能是HTTP协议。具体来说,就是HTTP协议里面四个表示操作方式的动词:GET(获取资源)、POST(新建资源或更新资源)、PUT(更新资源)、DELETE(删除资源)</li>\n</ul>\n</li>\n<li><p>RESTful架构:</p>\n<ul>\n<li>每一个URI代表一种资源</li>\n</ul>\n<ul>\n<li>客户端和服务器之间,传递这种资源的某种表现层</li>\n<li>客户端通过四个HTTP动词,对服务器端资源进行操作,实现”表现层状态转化”</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>RPC</p>\n<ul>\n<li>实现函数调用模式的网络化</li>\n<li>运行时,一次客户机对服务器的RPC调用,其内部操作大致有如下十步：<ol>\n<li>调用客户端句柄；执行传送参数</li>\n<li>调用本地系统内核发送网络消息</li>\n<li>消息传送到远程主机</li>\n<li>服务器句柄得到消息并取得参数</li>\n<li>执行远程过程</li>\n<li>执行的过程将结果返回服务器句柄</li>\n<li>服务器句柄返回结果，调用远程系统内核</li>\n<li>消息传回本地主机</li>\n<li>客户句柄由内核接收消息</li>\n<li>客户接收句柄返回的数据</li>\n</ol>\n</li>\n<li>Json RPC</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"安全与加密\"><a href=\"#安全与加密\" class=\"headerlink\" title=\"安全与加密\"></a>安全与加密</h2><ul>\n<li><p>预防CSRF攻击</p>\n<ul>\n<li><p>CSRF(Cross-site request forgery),跨站请求伪造,也被称为one click attack/session riding(CSRF/XSRF)</p>\n</li>\n<li><p>完成一次CSRF攻击受害者必须依次完成两个步骤</p>\n<ol>\n<li><p>登录受信任网站A，并在本地生成Cookie </p>\n</li>\n<li><p>在不退出A的情况下，访问危险网站B</p>\n</li>\n</ol>\n</li>\n<li><p>CSRF攻击主要是因为Web的隐式身份验证机制,Web的身份验证机制虽然可以保证一个请求是来自于某个用户的浏览器,但却无法保证该请求是用户批准发送的</p>\n</li>\n<li><p>预防CSRF</p>\n<p>CSRF的防御可以从服务端和客户端两方面着手,防御效果是从服务端着手效果比较好,现在一般的CSRF防御也都在服务端进行</p>\n<p>服务端的预防CSRF攻击的方式方法多种多样,但思想差不多的,主要从以下2个方面入手</p>\n<ul>\n<li><p>正确使用GET,POST和Cookie</p>\n</li>\n<li><p>在非GET请求中增加伪随机数</p>\n<ul>\n<li><p>为每个用户生成一个唯一的cookie token,所有表单都包含同一个伪随机值,这种方案最简单,因为攻击者不能获得第三方的Cookie(理论上),所以表单中的数据也就构造失败,但是由于用户的Cookie很容易由于网站的XSS漏洞而被盗取所以这个方案必须要在没有XSS的情况下才安全</p>\n</li>\n<li><p>每个请求使用验证码,这个方案是完美的,但因为要多次输入验证码,用户友好性很差,因此不适合实际运用</p>\n</li>\n<li><p>不同的表单包含一个不同的伪随机值,复用相关代码，实现如下：</p>\n<p>生成随机数token</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">h := md5.New()</span><br><span class=\"line\">io.WriteString(h, strconv.FormatInt(crutime, 10))</span><br><span class=\"line\">io.WriteString(h, &quot;ganraomaxxxxxxxxx&quot;)</span><br><span class=\"line\">token := fmt.Sprintf(&quot;%x&quot;, h.Sum(nil))</span><br><span class=\"line\"></span><br><span class=\"line\">t, _ := template.ParseFiles(&quot;login.gtpl&quot;)</span><br><span class=\"line\">t.Execute(w, token)</span><br></pre></td></tr></table></figure>\n<p>输出token</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;input type=&quot;hidden&quot; name=&quot;token&quot; value=&quot;&#123;&#123;.&#125;&#125;&quot;&gt;</span><br></pre></td></tr></table></figure>\n<p>验证token</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">r.ParseForm()</span><br><span class=\"line\">token := r.Form.Get(&quot;token&quot;)</span><br><span class=\"line\">if token != &quot;&quot; &#123;</span><br><span class=\"line\">    //验证token的合法性</span><br><span class=\"line\">&#125; else &#123;</span><br><span class=\"line\">    //不存在token报错</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这样基本就实现了安全的POST,因为实际上破解是基本不可能的,暴力破解该串大概需要2的11次方时间</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>确保输入过滤</p>\n<ul>\n<li><p>过滤用户数据是Web应用安全的基础,是验证数据合法性的过程。通过对所有的输入数据进行过滤,可以避免恶意数据在程序中被误信或误用</p>\n</li>\n<li><p>大多数Web应用的漏洞都是因为没有对用户输入的数据进行恰当过滤所引起的</p>\n</li>\n<li><p>过滤数据的三个步骤</p>\n<ol>\n<li><p>识别数据</p>\n<ul>\n<li>弄清楚需要过滤的数据来自于哪里</li>\n<li>由用户输入的数据通过Go非常容易识别,Go通过<code>r.ParseForm</code>之后,把用户POST和GET的数据全部放在了<code>r.Form</code>里面</li>\n<li>其它的输入要难识别得多(eg.<code>r.Header</code>中的很多元素是由客户端所操纵的),常常很难确认其中的哪些元素组成了输入,因此最好的方法是把里面所有的数据都看成是用户输入</li>\n</ul>\n</li>\n<li><p>过滤数据</p>\n<ul>\n<li>弄明白需要什么样的数据,防止非法数据进入</li>\n<li>最好的方法是把过滤看成是一个检查的过程,在使用数据之前都检查一下看它们是否是符合合法数据的要求。且不要试图好心地去纠正非法数据,而要让用户按制定的规则去输入数据。历史证明了试图纠正非法数据往往会导致安全漏洞</li>\n<li>过滤数据主要采用如下一些库来操作<ul>\n<li>strconv包下面的字符串转化相关函数,因为从Request中的<code>r.Form</code>返回的是字符串,而有些时候需要将之转化成整/浮点数,<code>Atoi</code>、<code>ParseBool</code>、<code>ParseFloat</code>、<code>ParseInt</code>等函数就可以派上用场</li>\n<li>string包下面的一些过滤函数<code>Trim</code>、<code>ToLower</code>、<code>ToTitle</code>等函数,能够帮助按照指定的格式获取信息</li>\n<li>regexp包用来处理一些复杂的需求(eg.判定输入是否是Email、生日之类)</li>\n</ul>\n</li>\n<li>过滤数据除了检查验证之外,在特殊时候,还可以采用白名单(假定你正在检查的数据都是非法的,除非能证明它是合法的),使用这个方法,如果出现错误,只会导致把合法的数据当成是非法的,而不会是相反,尽管不想犯任何错误,但总比把非法数据当成合法数据要安全得多</li>\n</ul>\n</li>\n<li><p>区分已过滤及被污染数据</p>\n<ul>\n<li><p>如果存在攻击数据那么保证过滤之后可使用更安全的数据</p>\n</li>\n<li><p>在编写Web应用的时候需要区分已过滤和被污染数据,因而保证过滤数据的完整性,而不影响输入的数据</p>\n</li>\n<li><p>约定把所有经过过滤的数据放入一个叫全局的Map变量中(CleanMap),这时需要用两个重要的步骤来防止被污染数据的注入</p>\n<ul>\n<li>每个请求都要初始化CleanMap为一个空Map</li>\n<li>加入检查及阻止来自外部数据源的变量命名为CleanMap</li>\n</ul>\n<p>如下例</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;form action=<span class=\"string\">\"/whoami\"</span> method=<span class=\"string\">\"POST\"</span>&gt;</span><br><span class=\"line\">    我是谁:</span><br><span class=\"line\">    &lt;<span class=\"keyword\">select</span> name=<span class=\"string\">\"name\"</span>&gt;</span><br><span class=\"line\">        &lt;option value=\"astaxie\"&gt;astaxie&lt;/option&gt;</span><br><span class=\"line\">        &lt;option value=\"herry\"&gt;herry&lt;/option&gt;</span><br><span class=\"line\">        &lt;option value=\"marry\"&gt;marry&lt;/option&gt;</span><br><span class=\"line\">    &lt;/select&gt;</span><br><span class=\"line\">    &lt;input <span class=\"keyword\">type</span>=<span class=\"string\">\"submit\"</span> /&gt;</span><br><span class=\"line\">&lt;/form&gt;</span><br></pre></td></tr></table></figure>\n<p>在处理这个表单的编程逻辑中,非常容易犯的错误是认为只能提交三个选择中的一个。其实攻击者可以模拟POST操作,递交<code>name=attack</code>这样的数据,所以在此时需要做类似白名单的处理</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">r.ParseForm()</span><br><span class=\"line\">name := r.Form.Get(<span class=\"string\">\"name\"</span>)</span><br><span class=\"line\">CleanMap := <span class=\"built_in\">make</span>(<span class=\"keyword\">map</span>[<span class=\"keyword\">string</span>]<span class=\"keyword\">interface</span>&#123;&#125;, <span class=\"number\">0</span>)</span><br><span class=\"line\"><span class=\"keyword\">if</span> name == <span class=\"string\">\"a\"</span> || name == <span class=\"string\">\"herry\"</span> || name == <span class=\"string\">\"marry\"</span> &#123;</span><br><span class=\"line\">    CleanMap[<span class=\"string\">\"name\"</span>] = name</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面代码中初始化了一个CleanMap的变量,当判断获取的name是<code>a</code>、<code>herry</code>、<code>marry</code>三个中的一个之后 ，把数据存储到了CleanMap之中，这样就可以确保CleanMap[“name”]中的数据是合法的,从而在代码的其它部分使用它。当然还可以在else部分增加非法数据的处理,一种可能是再次显示表单并提示错误。但是不要试图为了友好而输出被污染的数据</p>\n<p>上面的方法对于过滤一组已知的合法值的数据很有效,但是对于过滤有一组已知合法字符组成的数据时就没有什么帮助。</p>\n<p>例如，可能需要一个用户名只能由字母及数字组成：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">r.ParseForm()</span><br><span class=\"line\">username := r.Form.Get(<span class=\"string\">\"username\"</span>)</span><br><span class=\"line\">CleanMap := <span class=\"built_in\">make</span>(<span class=\"keyword\">map</span>[<span class=\"keyword\">string</span>]<span class=\"keyword\">interface</span>&#123;&#125;, <span class=\"number\">0</span>)</span><br><span class=\"line\"><span class=\"keyword\">if</span> ok, _ := regexp.MatchString(<span class=\"string\">\"^[a-zA-Z0-9].$\"</span>, username); ok &#123;</span><br><span class=\"line\">    CleanMap[<span class=\"string\">\"username\"</span>] = username</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n</ol>\n</li>\n</ul>\n</li>\n<li><p>避免XSS攻击</p>\n<ul>\n<li>动态内容,是应用程序能够根据用户环境和用户请求,输出相应的内容。动态站点会受到一种名为跨站脚本攻击”(Cross Site Scripting, XSS)的威胁,而静态站点则完全不受其影响</li>\n<li>XSS允许攻击者将恶意代码植入到提供给其它用户使用的页面中,不同于大多数攻击(一般只涉及攻击者和受害者),其涉及到三方,即攻击者、客户端与Web应用</li>\n<li>XSS的攻击目标是为了盗取存储在客户端的cookie或者其他网站用于识别客户端身份的敏感信息。一旦获取到合法用户的信息,攻击者甚至可以假冒合法用户与网站进行交互</li>\n<li>两大类<ul>\n<li>存储型XSS<ul>\n<li>主要出现在让用户输入数据,供其他浏览此页的用户进行查看的地方(eg.留言,评论,博客,日志,各类表单etc.)</li>\n<li>应用程序从数据库中查询数据,在页面中显示出来,攻击者在相关页面输入恶意的脚本数据后,用户浏览此类页面时就可能受到攻击</li>\n<li>这个流程简单可以描述为:恶意用户的Html输入Web程序-&gt;进入数据库-&gt;Web程序-&gt;用户浏览器</li>\n</ul>\n</li>\n<li>反射型XSS<ul>\n<li>将脚本代码加入URL地址的请求参数里</li>\n<li>请求参数进入程序后在页面直接输出</li>\n<li>用户点击类似的恶意链接就可能受到攻击</li>\n</ul>\n</li>\n<li>XSS目前主要的手段和目的如下<ul>\n<li>盗用cookie,获取敏感信息</li>\n<li>利用植入Flash,通过crossdomain权限设置进一步获取更高权限;或者利用Java等得到类似的操作</li>\n<li>利用iframe、frame、XMLHttpRequest或上述Flash等方式,以（被攻击者）用户的身份执行一些管理动作,或执行一些常规操作(eg:发微博,加好友,发私信,etc.)</li>\n<li>利用可被攻击的域受到其他域信任的特点,以受信任来源的身份请求一些平时不允许的操作(eg.进行不当的投票活动)</li>\n<li>在访问量极大的一些页面上的XSS可以攻击一些小型网站,实现DDoS攻击的效果</li>\n</ul>\n</li>\n<li>原理<ul>\n<li>Web应用未对用户提交请求的数据做充分的检查过滤,允许用户在提交的数据中掺入HTML代码(最主要的是“&gt;”、“&lt;”),并将未经转义的恶意代码输出到第三方用户的浏览器解释执行</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>避免SQL注入</p>\n</li>\n<li><p>存储密码</p>\n</li>\n<li><p>加密和解密数据</p>\n</li>\n</ul>\n<h1 id=\"Redis\"><a href=\"#Redis\" class=\"headerlink\" title=\"Redis\"></a>Redis</h1><ul>\n<li><p>关于Redis</p>\n<ul>\n<li><p>Redis是一个使用ANSI C编写的开源、支持网络、基于内存、可选持久性的键值对存储数据库</p>\n</li>\n<li><p>Redis的外围由一个键、值映射的字典构成,与其他非关系型数据库主要不同在于：Redis中值的类型不仅限于字符串,还支持如下抽象数据类型:</p>\n<ul>\n<li>字符串列表</li>\n<li>无序不重复的字符串集合</li>\n<li>有序不重复的字符串集合</li>\n<li>键、值都为字符串的哈希表</li>\n</ul>\n<p>值的类型决定了值本身支持的操作。Redis支持不同无序、有序的列表，无序、有序的集合间的交集、并集等高级服务器端原子操作数据模型编辑</p>\n</li>\n</ul>\n</li>\n<li><p>安装</p>\n<p>在mac下可以直接用homebrew进行安装</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">brew install redis</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n","categories":["我爱学习"],"tags":["日常学习","日常"]},{"title":"每日学习笔记(2018.8.23)","url":"https://yixiaoer.github.io/2018/08/23/日常学习笔记(2018.8.23)/","content":"<p><strong>每日学习笔记</strong><br>Web学习相关内容<br>大部分都只是所看的记录<br><em>2018.8.23</em> 《Go Web》前六章复习及第七章;Docker安装及《Docker实践到入门》使用镜像部分;正则表达式</p>\n<h1 id=\"《Go-Web》\"><a href=\"#《Go-Web》\" class=\"headerlink\" title=\"《Go Web》\"></a>《Go Web》</h1><h2 id=\"Web基础\"><a href=\"#Web基础\" class=\"headerlink\" title=\"Web基础\"></a>Web基础</h2><h2 id=\"表单\"><a href=\"#表单\" class=\"headerlink\" title=\"表单\"></a>表单</h2><ul>\n<li><p>表单是一个包含表单元素的区域,允许用户在表单中(eg.文本域、下拉列表、单选框、复选框etc.）输入信息的元素,使用表单标签(\\)定义</p>\n</li>\n<li><p>在服务器端验证表单的输入</p>\n<ul>\n<li><p><strong>必填字段</strong></p>\n<p>用内置函数<code>len</code>可以获取字符串的长度,以此来获取数据的长度</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> <span class=\"built_in\">len</span>(r.Form[<span class=\"string\">\"username\"</span>][<span class=\"number\">0</span>])==<span class=\"number\">0</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//为空的处理</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>r.Form</code>对不同类型的表单元素的留空有不同的处理,对于空文本框、空文本区域以及文件上传,元素的值为空值,而如果是未选中的复选框和单选按钮,则根本不会在r.Form中产生相应条目</p>\n<p>若用上面例子中的方式去获取数据时程序就会报错</p>\n<p>因此需要通过<code>r.Form.Get()</code>来获取值,因为如果字段不存在,通过该方式获取的是空值</p>\n<p>但是通过<code>r.Form.Get()</code>只能获取单个的值,若是map的值,必须通过上面的方式来获取</p>\n</li>\n<li><p><strong>数字</strong></p>\n<p>如果是判断正整数,那么先将表单获得的数据转化成int类型,然后进行处理</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">getint,err:=strconv.Atoi(r.Form.Get(<span class=\"string\">\"age\"</span>))</span><br><span class=\"line\"><span class=\"keyword\">if</span> err!=<span class=\"literal\">nil</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//数字转化出错了，那么可能就不是数字</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//接下来就可以判断这个数字的大小范围了</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> getint &gt;<span class=\"number\">100</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//太大了,大于100则如何如何</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>还有一种方式就是正则匹配的方式</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> m, _ := regexp.MatchString(<span class=\"string\">\"^[0-9]+$\"</span>, r.Form.Get(<span class=\"string\">\"age\"</span>)); !m &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>中文</strong></p>\n<ul>\n<li><p>使用 <code>unicode</code> 包提供的 <code>func Is(rangeTab *RangeTable, r rune) bool</code> 来验证</p>\n</li>\n<li><p>使用正则方式来验证,这里使用最简单的正则方式,如下:</p>\n</li>\n</ul>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> m, _ := regexp.MatchString(<span class=\"string\">\"^\\\\p&#123;Han&#125;+$\"</span>, r.Form.Get(<span class=\"string\">\"realname\"</span>)); !m &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>英文</strong></p>\n<p>期望通过表单元素获取一个英文值可以很简单的通过正则验证数据：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> m, _ := regexp.MatchString(<span class=\"string\">\"^[a-zA-Z]+$\"</span>, r.Form.Get(<span class=\"string\">\"engname\"</span>)); !m &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>电子邮箱地址</strong></p>\n<p>想知道用户输入的一个Email地址是否正确,可通过如下这个方式验证：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> m, _ := regexp.MatchString(<span class=\"string\">`^([\\w\\.\\_]&#123;2,10&#125;)@(\\w&#123;1,&#125;).([a-z]&#123;2,4&#125;)$`</span>, r.Form.Get(<span class=\"string\">\"email\"</span>)); !m &#123;</span><br><span class=\"line\">    fmt.Println(<span class=\"string\">\"no\"</span>)</span><br><span class=\"line\">&#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">    fmt.Println(<span class=\"string\">\"yes\"</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>手机号码</strong></p>\n<p>想要判断用户输入的手机号码是否正确,通过正则也可以验证：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> m, _ := regexp.MatchString(<span class=\"string\">`^(1[3|4|5|8][0-9]\\d&#123;4,8&#125;)$`</span>, r.Form.Get(<span class=\"string\">\"mobile\"</span>)); !m &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>下拉菜单</strong></p>\n<p>想要判断表单里面<code>&lt;select&gt;</code>元素生成的下拉菜单中是否有被选中的项目</p>\n<p>判断这个值是否是预设的值</p>\n<p>select可能是这样的一些元素</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">select</span> <span class=\"attr\">name</span>=<span class=\"string\">\"fruit\"</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">option</span> <span class=\"attr\">value</span>=<span class=\"string\">\"apple\"</span>&gt;</span>apple<span class=\"tag\">&lt;/<span class=\"name\">option</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">option</span> <span class=\"attr\">value</span>=<span class=\"string\">\"pear\"</span>&gt;</span>pear<span class=\"tag\">&lt;/<span class=\"name\">option</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">option</span> <span class=\"attr\">value</span>=<span class=\"string\">\"banane\"</span>&gt;</span>banane<span class=\"tag\">&lt;/<span class=\"name\">option</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">select</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>可以这样来验证</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">slice:=[]<span class=\"keyword\">string</span>&#123;<span class=\"string\">\"apple\"</span>,<span class=\"string\">\"pear\"</span>,<span class=\"string\">\"banane\"</span>&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> _, v := <span class=\"keyword\">range</span> slice &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> v == r.Form.Get(<span class=\"string\">\"fruit\"</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>单选按钮</strong></p>\n<p>判断我们获取的值是我们预设的值，而不是额外的值</p>\n<p>预设的值如下</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"radio\"</span> <span class=\"attr\">name</span>=<span class=\"string\">\"gender\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"1\"</span>&gt;</span>男</span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"radio\"</span> <span class=\"attr\">name</span>=<span class=\"string\">\"gender\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"2\"</span>&gt;</span>女</span><br></pre></td></tr></table></figure>\n<p>也可以类似下拉菜单的做法,进行如下验证</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">slice:=[]<span class=\"keyword\">int</span>&#123;<span class=\"number\">1</span>,<span class=\"number\">2</span>&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> _, v := <span class=\"keyword\">range</span> slice &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> v == r.Form.Get(<span class=\"string\">\"gender\"</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>时间和日期</strong></p>\n<p>想确定用户填写的日期或时间是否有效(eg.用户在日程表中安排8月份的第45天开会,或者提供未来的某个时间作为生日)</p>\n<p>Go里面提供了一个time的处理包,可以把用户的输入年月日转化成相应的时间,然后进行逻辑判断</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">t := time.Date(<span class=\"number\">2009</span>, time.November, <span class=\"number\">10</span>, <span class=\"number\">23</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, time.UTC)</span><br><span class=\"line\">fmt.Printf(<span class=\"string\">\"Go launched at %s\\n\"</span>, t.Local())</span><br></pre></td></tr></table></figure>\n<p>获取time之后就可以进行很多时间函数的操作</p>\n</li>\n<li><p><strong>身份证号码</strong></p>\n<p>想验证表单输入的是否是身份证,通过正则也可以方便的验证</p>\n<p>身份证有15位和18位,两个都需要验证</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//验证15位身份证，15位的是全部数字</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> m, _ := regexp.MatchString(<span class=\"string\">`^(\\d&#123;15&#125;)$`</span>, r.Form.Get(<span class=\"string\">\"usercard\"</span>)); !m &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//验证18位身份证，18位前17位为数字，最后一位是校验位，可能为数字或字符X。</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> m, _ := regexp.MatchString(<span class=\"string\">`^(\\d&#123;17&#125;)([0-9]|X)$`</span>, r.Form.Get(<span class=\"string\">\"usercard\"</span>)); !m &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li><p>预防跨站脚本</p>\n<ul>\n<li>现在的网站包含大量的动态内容以提高用户体验,所谓动态内容,就是根据用户环境和需要,Web应用程序能够输出相应的内容</li>\n<li>动态站点会受到一种名为””跨站脚本攻击”(Cross Site Scripting, XSS)的威胁,而静态站点则完全不受其影响</li>\n<li>攻击者通常会在有漏洞的程序中插入JavaScript、VBScript、 ActiveX或Flash以欺骗用户,一旦得手,可以盗取用户帐户信息、修改用户设置、盗取/污染cookie、植入恶意广告…</li>\n<li>对XSS最佳的防护应该结合以下两种方法<ul>\n<li>验证所有输入数据,有效检测攻击(即验证表单输入内容)</li>\n<li>对所有输出数据进行适当的处理,以防止任何已成功注入的脚本在浏览器端运行</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>防止多次递交表单</p>\n<ul>\n<li><p>在表单中添加一个带有唯一值的隐藏字段,在验证表单时,先检查带有该唯一值的表单是否已经递交过了</p>\n<ul>\n<li>是则拒绝再次递交</li>\n<li>不是则处理表单进行逻辑处理</li>\n</ul>\n<p>举例如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;input type=&quot;checkbox&quot; name=&quot;interest&quot; value=&quot;football&quot;&gt;足球</span><br><span class=\"line\">&lt;input type=&quot;checkbox&quot; name=&quot;interest&quot; value=&quot;basketball&quot;&gt;篮球</span><br><span class=\"line\">&lt;input type=&quot;checkbox&quot; name=&quot;interest&quot; value=&quot;tennis&quot;&gt;网球    </span><br><span class=\"line\">用户名:&lt;input type=&quot;text&quot; name=&quot;username&quot;&gt;</span><br><span class=\"line\">密码:&lt;input type=&quot;password&quot; name=&quot;password&quot;&gt;</span><br><span class=\"line\">&lt;input type=&quot;hidden&quot; name=&quot;token&quot; value=&quot;&#123;&#123;.&#125;&#125;&quot;&gt;</span><br><span class=\"line\">&lt;input type=&quot;submit&quot; value=&quot;登陆&quot;&gt;</span><br></pre></td></tr></table></figure>\n<p>在模版里面增加了一个隐藏字段<code>token</code>,这个值通过MD5(时间戳)来获取唯一值,然后把这个值存储到服务器端(session来控制),以方便表单提交时比对判定</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func login(w http.ResponseWriter, r *http.Request) &#123;</span><br><span class=\"line\">    fmt.Println(&quot;method:&quot;, r.Method) //获取请求的方法</span><br><span class=\"line\">    if r.Method == &quot;GET&quot; &#123;</span><br><span class=\"line\">        crutime := time.Now().Unix()</span><br><span class=\"line\">        h := md5.New()</span><br><span class=\"line\">        io.WriteString(h, strconv.FormatInt(crutime, 10))</span><br><span class=\"line\">        token := fmt.Sprintf(&quot;%x&quot;, h.Sum(nil))</span><br><span class=\"line\"></span><br><span class=\"line\">        t, _ := template.ParseFiles(&quot;login.gtpl&quot;)</span><br><span class=\"line\">        t.Execute(w, token)</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">        //请求的是登陆数据，那么执行登陆的逻辑判断</span><br><span class=\"line\">        r.ParseForm()</span><br><span class=\"line\">        token := r.Form.Get(&quot;token&quot;)</span><br><span class=\"line\">        if token != &quot;&quot; &#123;</span><br><span class=\"line\">            //验证token的合法性</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">            //不存在token报错</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        fmt.Println(&quot;username length:&quot;, len(r.Form[&quot;username&quot;][0]))</span><br><span class=\"line\">        fmt.Println(&quot;username:&quot;, template.HTMLEscapeString(r.Form.Get(&quot;username&quot;))) //输出到服务器端</span><br><span class=\"line\">        fmt.Println(&quot;password:&quot;, template.HTMLEscapeString(r.Form.Get(&quot;password&quot;)))</span><br><span class=\"line\">        template.HTMLEscape(w, []byte(r.Form.Get(&quot;username&quot;))) //输出到客户端</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>如果是采用了Ajax模式递交表单的话，当表单递交后，通过javascript来禁用表单的递交按钮</p>\n</li>\n</ul>\n</li>\n<li><p>处理文件上传</p>\n<ul>\n<li>要使表单能够上传文件,首先要添加form的<code>enctype</code>属性<ul>\n<li>application/x-www-form-urlencoded   表示在发送前编码所有字符(默认)</li>\n<li>multipart/form-data         不对字符编码,在使用包含文件上传控件的表单时,必须使用该值</li>\n<li>text/plain      空格转换为 “+” 加号,但不对特殊字符编码</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"访问数据库\"><a href=\"#访问数据库\" class=\"headerlink\" title=\"访问数据库\"></a>访问数据库</h2><p>mongdb</p>\n<h2 id=\"session和数据存储\"><a href=\"#session和数据存储\" class=\"headerlink\" title=\"session和数据存储\"></a>session和数据存储</h2><ul>\n<li><p>cookie机制</p>\n<ul>\n<li>一种客户端机制,把用户数据保存在客户端</li>\n<li>在本地计算机保存一些用户操作的历史信息(包括登录信息),并在用户再次访问该站点时浏览器通过HTTP协议将本地cookie内容发送给服务器,从而完成验证或继续上一步操作</li>\n<li>由浏览器维持的,存储在客户端的一小段文本信息,伴随着用户请求和页面在Web服务器和浏览器之间传递</li>\n<li>有时间限制<ul>\n<li>会话cookie<ul>\n<li>不保存在硬盘上而是保存在内存里</li>\n<li>不设置过期时间,这个cookie生命周期为从创建到浏览器关闭止,只要关闭浏览器窗口,cookie就消失了</li>\n</ul>\n</li>\n<li>持久cookie<ul>\n<li>保存在硬盘上</li>\n<li>设置了过期时间(setMaxAge(60<em>60</em>24)),浏览器会把cookie保存到硬盘上,关闭后再次打开浏览器这些cookie依然有效直到超过设定的过期</li>\n<li>存储在硬盘上的cookie可以在不同的浏览器进程间共享(eg.两个IE窗口)</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>session机制</p>\n<ul>\n<li>中文常译为会话,本义是有始有终的一系列动作/消息(eg.打电话是从拿起电话拨号到挂断电话这中间的一系列过程可以称之为一个session),然而当session一词与网络协议相关联时,又往往隐含了“面向连接”和/或“保持状态”这样两个含义;session在Web开发环境下的语义又有了新的扩展,指一类用来在客户端与服务器端之间保持状态的解决方案;有时也用来指这种解决方案的存储结构</li>\n<li>一种服务器端的机制,服务器使用一种类似于散列表的结构(也可能就是使用散列表)来保存信息,每一个网站访客都会被分配给一个唯一的标志符,即sessionID,服务器用它来标识session,它由服务器负责产生,保证随机性与唯一性,相当于一个随机密钥,避免在握手或传输中暴露用户真实密码</li>\n<li><p>程序需某个客户端的请求创建一个session的时,服务器首先检查这个客户端的请求里是否包含了一个session标识(session id),如果已经包含一个session id则说明以前已经为此客户创建过session,服务器就按照session id把这个session检索出来使用(如果检索不到,可能会新建一个.这种情况可能出现在服务端已经删除了该用户对应的session对象,但用户人为地在请求的URL后面附加上一个JSESSION的参数)。如果客户请求不包含session id,则为此客户创建一个session并且同时生成一个与此session相关联的session id,这个session id将在本次响应中返回给客户端保存</p>\n</li>\n<li><p>session ID的存放形式</p>\n<ul>\n<li>保存在客户端的cookies里<ul>\n<li>通过设置Set-cookie头就可以将session的标识符传送到客户端</li>\n<li>客户端此后的每一次请求都会带上这个标识符</li>\n<li>一般包含session信息的cookie会将失效时间设置为0(会话cookie),即浏览器进程有效时间,至于浏览器怎么处理这个0每个浏览器都有自己的方案,但差别都不会太大(一般体现在新建浏览器窗口的时候)</li>\n</ul>\n</li>\n<li>经过url传递<ul>\n<li>即URL重写,在返回给用户的页面里的所有的URL后面追加session标识符</li>\n<li>用户在收到响应之后,无论点击响应页面里的哪个链接或提交表单,都会自动带上session标识符,从而就实现了会话的保持</li>\n<li>虽然这种做法比较麻烦,但客户端禁用了cookie的话,此方案将是首选</li>\n</ul>\n</li>\n<li>将Session保存到数据库里<ul>\n<li>这更安全</li>\n<li>效率方面会有所下降</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>session管理<ul>\n<li>全局session管理器</li>\n<li>保证sessionid 的全局唯一性</li>\n<li>为每个客户关联一个session</li>\n<li>session 的存储(可以存储到内存、文件、数据库等)</li>\n<li>session 过期处理</li>\n</ul>\n</li>\n</ul>\n</li>\n<li></li>\n</ul>\n<h2 id=\"文本文件处理\"><a href=\"#文本文件处理\" class=\"headerlink\" title=\"文本文件处理\"></a>文本文件处理</h2><ul>\n<li>XML处理</li>\n<li>JSON处理</li>\n<li>正则处理</li>\n<li>模版处理</li>\n<li>文件操作</li>\n<li>字符串处理</li>\n</ul>\n<h1 id=\"Docker\"><a href=\"#Docker\" class=\"headerlink\" title=\"Docker\"></a>Docker</h1><ul>\n<li><p>Docker 是什么</p>\n<ul>\n<li>一个开源软件项目，让应用程序布署在软件容器下的工作可以自动化进行</li>\n<li>容器是完全使用<a href=\"https://zh.wikipedia.org/wiki/%E6%B2%99%E7%9B%92_(%E9%9B%BB%E8%85%A6%E5%AE%89%E5%85%A8\" target=\"_blank\" rel=\"noopener\">沙箱机制</a>)，相互之间不会有任何接口,且容器性能开销极低</li>\n<li>与传统虚拟机比较<ul>\n<li>传统虚拟机技术是虚拟出一套硬件后,在其上运行一个完整操作系统,在该系统上再运行所需应用进程</li>\n<li>Docker容器内的应用进程直接运行于宿主的内核,容器内没有自己的内核,也没有进行硬件虚拟</li>\n</ul>\n</li>\n<li>Docker 架构<ul>\n<li>使用客户端-服务器 (C/S) 架构模式,使用远程API来管理和创建Docker容器</li>\n<li>Docker 容器通过 Docker 镜像来创建</li>\n<li>容器与镜像的关系类似于面向对象编程中的对象与类,镜像是静态的定义，容器是镜像运行时的实体</li>\n</ul>\n</li>\n<li>Docker 的三个基本概念<ul>\n<li>镜像（<code>Image</code>）<ul>\n<li>用于创建 Docker 容器的模版</li>\n<li>Docker 运行容器前需要本地存在对应的镜像,如果本地不存在该镜像,Docker 会从镜像仓库下载该镜像</li>\n<li>Docker 镜像是一个特殊的文件系统,除了提供容器运行时所需的程序、库、资源、配置等文件外,还包含了一些为运行时准备的一些配置参数(如匿名卷、环境变量、用户等),它不包含任何动态数据,其内容在构建之后也不会被改变</li>\n<li>镜像构建时,会一层层构建,前一层是后一层的基础镜像只是一个虚拟的概念,其实际体现并非由一个文件组成,而是由一组文件系统组成,或者说,由多层文件系统联合组成</li>\n<li>每一层构建完就不会再发生改变，后一层上的任何改变只发生在自己这一层(eg.删除前一层文件的操作,实际不是真的删除前一层的文件,而是仅在当前层标记为该文件已删除。在最终容器运行的时候,虽然不会看到这个文件,但是实际上该文件会一直跟随镜像。因此,在构建镜像的时候,需要额外小心,每一层尽量只包含该层需要添加的东西,任何额外的东西应该在该层构建结束前清理掉</li>\n<li>也用之前构建好的镜像作为基础层,然后进一步添加新的层,以定制自己所需的内容,构建新的镜像</li>\n</ul>\n</li>\n<li>容器（<code>Container</code>）<ul>\n<li>独立运行的一个或一组应用</li>\n<li>容器可以被创建、启动、停止、删除、暂停等</li>\n<li>容器的实质是进程,但与直接在宿主执行的进程不同,容器进程运行于属于自己的独立的命名空间。因此容器可以拥有自己的 <code>root</code> 文件系统、自己的网络配置、自己的进程空间,甚至自己的用户 ID 空间</li>\n<li>容器内的进程是运行在一个隔离的环境里,使用起来,就好像是在一个独立于宿主的系统下操作一样</li>\n<li>容器和镜像一样也是使用分层储存,每一个容器运行时,是以镜像为基础层,在其上创建一个当前容器的存储层,称这个为容器运行时读写而准备的存储层为<strong>容器存储层</strong><ul>\n<li>容器存储层的生存周期和容器一样,容器消亡时,容器存储层也随之消亡。因此,任何保存于容器存储层的信息都会随容器删除而丢失</li>\n<li>一般而言,容器不应该向其存储层内写入任何数据,容器存储层要保持无状态化,所有的文件写入操作,都应该使用 <a href=\"https://yeasy.gitbooks.io/docker_practice/content/data_management/volume.html\" target=\"_blank\" rel=\"noopener\">数据卷(Volume)</a>、或者绑定宿主目录,在这些位置的读写会跳过容器存储层,直接对宿主（或网络存储）发生读写,其性能和稳定性更高</li>\n<li>数据卷的生存周期独立于容器,容器消亡，数据卷不会消亡。因此,使用数据卷后,容器删除或者重新运行之后,数据却不会丢失</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>仓库（<code>Repository</code>）<ul>\n<li>用来保存镜像,可以理解为代码控制中的代码仓库</li>\n<li>镜像构建完成后,可以很容易的在当前宿主机上运行,但若需要在其它服务器上使用这个镜像,则需要一个集中的存储、分发镜像的服务,<a href=\"https://yeasy.gitbooks.io/docker_practice/content/repository/registry.html\" target=\"_blank\" rel=\"noopener\">Docker Registry</a> 就是这样的服务</li>\n<li>一个 Docker Registry 中可以包含多个仓库(Repository);每个仓库可以包含多个标签(Tag);每个标签对应一个镜像</li>\n<li>通常,一个仓库会包含同一个软件不同版本的镜像,而标签就常用于对应该软件的各个版本,可以通过 <code>&lt;仓库名&gt;:&lt;标签&gt;</code> 的格式来指定具体是这个软件哪个版本的镜像;若如果不给出标签,将以 <code>latest</code> 作为默认标签</li>\n<li>仓库名经常以 <em>两段式路径</em> 形式出现,比如 <code>name/nginx-proxy</code>,前者往往意味着 Docker Registry 多用户环境下的用户名,后者则往往是对应的软件名</li>\n<li>最常使用的 Registry 公开服务是官方的 <a href=\"https://hub.docker.com/\" target=\"_blank\" rel=\"noopener\">Docker Hub</a>,这也是默认的 Registry,除此以外,还有 <a href=\"https://coreos.com/\" target=\"_blank\" rel=\"noopener\">CoreOS</a> 的 <a href=\"https://quay.io/repository/\" target=\"_blank\" rel=\"noopener\">Quay.io</a>,CoreOS 相关的镜像存储在这里;Google 的 <a href=\"https://cloud.google.com/container-registry/\" target=\"_blank\" rel=\"noopener\">Google Container Registry</a>,<a href=\"http://kubernetes.io/\" target=\"_blank\" rel=\"noopener\">Kubernetes</a> 的镜像使用的就是这个服务</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>Docker的安装与镜像加速</p>\n<ul>\n<li><p>安装</p>\n<ul>\n<li><p>可以利用homebrew进行安装</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span> brew cask install docker手动下载安装</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>手动下载</p>\n<p>请点击以下链接下载 <a href=\"https://download.docker.com/mac/stable/Docker.dmg\" target=\"_blank\" rel=\"noopener\">Stable</a> 或 <a href=\"https://download.docker.com/mac/edge/Docker.dmg\" target=\"_blank\" rel=\"noopener\">Edge</a> 版本的 Docker for Mac</p>\n<p>之后双击下载的 <code>.dmg</code> 文件，然后将鲸鱼图标拖拽到 <code>Application</code> 文件夹即可(其间需要输入用户密码)</p>\n</li>\n</ul>\n</li>\n<li><p>镜像加速</p>\n<ul>\n<li><p>在任务栏点击 Docker for mac 应用图标 -&gt; Perferences… -&gt; Daemon -&gt; Registry mirrors</p>\n</li>\n<li><p>在列表中填写加速器地址</p>\n<ul>\n<li>Docker 官方提供<code>https://registry.docker-cn.com</code></li>\n<li>七牛云 <code>https://reg-mirror.qiniu.com/</code></li>\n<li>网易<code>http://hub-mirror.c.163.com</code></li>\n</ul>\n</li>\n<li><p>之后可在终端通过</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker info</span><br></pre></td></tr></table></figure>\n<p>查看镜像是否配置成功</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>使用镜像</p>\n<ul>\n<li><p>获取镜像</p>\n<p>从 Docker 镜像仓库获取镜像的命令是 <code>docker pull</code>。其命令格式为：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker pull [选项] [Docker Registry 地址[:端口号]/]仓库名[:标签]</span><br></pre></td></tr></table></figure>\n<ul>\n<li>具体的选项可以通过 <code>docker pull --help</code> 命令看到</li>\n<li>镜像名称的格式<ul>\n<li>Docker 镜像仓库地址：地址的格式一般是 <code>&lt;域名/IP&gt;[:端口号]</code>。默认地址是 Docker Hub</li>\n<li>仓库名：如之前所说，这里的仓库名是两段式名称，即 <code>&lt;用户名&gt;/&lt;软件名&gt;</code>。对于 Docker Hub，如果不给出用户名，则默认为 <code>library</code>，也就是官方镜像。</li>\n</ul>\n</li>\n</ul>\n<p>有了镜像后，我们就能够以这个镜像为基础启动并运行一个容器,运行容器的命令:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker run</span><br></pre></td></tr></table></figure>\n<p>最后通过<code>exit</code>退出这个容器</p>\n</li>\n<li><p>列出镜像</p>\n</li>\n<li><p>删除本地镜像</p>\n</li>\n<li><p>利用commit理解镜像构成</p>\n</li>\n<li><p>Dockerfile指令</p>\n</li>\n<li><p>Dockerfile多阶段构建</p>\n</li>\n<li><p>其他制作镜像的方式</p>\n</li>\n<li><p>实现原理</p>\n</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"正则表达式\"><a href=\"#正则表达式\" class=\"headerlink\" title=\"正则表达式\"></a>正则表达式</h1><h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><ul>\n<li><p>正则表达式(Regular Expression)是一种文本模式,包括普通字符(例如，a 到 z 之间的字母)和特殊字符(称为”元字符”),是记录文本规则的代码</p>\n</li>\n<li><p>正则表达式使用单个字符串来描述、匹配一系列符合某个句法规则的字符串</p>\n</li>\n<li><p>通过使用正则表达式,可以：</p>\n<ul>\n<li><p>测试字符串内的模式</p>\n<p>可以测试输入字符串,以查看字符串内是否出现电话号码模式或信用卡号码模式,这称为数据验证</p>\n</li>\n<li><p>替换文本<br>可以使用正则表达式来识别文档中的特定文本,完全删除该文本或者用其他文本替换它</p>\n</li>\n<li><p>基于模式匹配从字符串中提取子字符串<br>可以查找文档内或输入域内特定的文本</p>\n</li>\n</ul>\n</li>\n<li><p>语法</p>\n<ul>\n<li><p>普通字符</p>\n<ul>\n<li><p>包括<em>没有显式指定为元字符的</em>所有<strong>可打印</strong>和<strong>不可打印</strong>字符,包括所有大写和小写字母、所有数字、所有标点符号和一些其他符号普通字符</p>\n</li>\n<li><p>包含</p>\n<ul>\n<li><p>非打印字符</p>\n<p>| 字符 | 描述                                                         |<br>| —- | ———————————————————— |<br>| \\cx  | 匹配由x指明的控制字符。例如， \\cM 匹配一个 Control-M 或回车符。x 的值必须为 A-Z 或 a-z 之一。否则，将 c 视为一个原义的 ‘c’ 字符。 |<br>| \\f   | 匹配一个换页符。等价于 \\x0c 和 \\cL。                         |<br>| \\n   | 匹配一个换行符。等价于 \\x0a 和 \\cJ。                         |<br>| \\r   | 匹配一个回车符。等价于 \\x0d 和 \\cM。                         |<br>| \\s   | 匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ \\f\\n\\r\\t\\v]。注意 Unicode 正则表达式会匹配全角空格符。 |<br>| \\S   | 匹配任何非空白字符。等价于 [^ \\f\\n\\r\\t\\v]。                  |<br>| \\t   | 匹配一个制表符。等价于 \\x09 和 \\cI。                         |<br>| \\v   | 匹配一个垂直制表符。等价于 \\x0b 和 \\cK。                     |</p>\n</li>\n<li><p>特殊字符</p>\n<p>一些有特殊含义的字符</p>\n<p>许多元字符要求在试图匹配它们时特别对待</p>\n<p>若要匹配这些特殊字符，必须首先使字符”转义”,即将反斜杠字符<code>\\</code> 放在它们前面</p>\n<p>| 特别字符 | 描述                                                         |<br>| ——– | ———————————————————— |<br>| $        | 匹配输入字符串的结尾位置。如果设置了 RegExp 对象的 Multiline 属性，则 $ 也匹配 ‘\\n’ 或 ‘\\r’。要匹配 $ 字符本身，请使用 \\$。 |<br>| ( )      | 标记一个子表达式的开始和结束位置。子表达式可以获取供以后使用。要匹配这些字符，请使用 ( 和 )。 |<br>| <em>        | 匹配前面的子表达式零次或多次。要匹配 </em> 字符，请使用 *。     |<br>| +        | 匹配前面的子表达式一次或多次。要匹配 + 字符，请使用 +。     |<br>| .        | 匹配除换行符 \\n 之外的任何单字符。要匹配 . ，请使用 . 。    |<br>| [        | 标记一个中括号表达式的开始。要匹配 [，请使用 [。            |<br>| ?        | 匹配前面的子表达式零次或一次，或指明一个非贪婪限定符。要匹配 ? 字符，请使用 \\?。 |<br>| \\        | 将下一个字符标记为或特殊字符、或原义字符、或向后引用、或八进制转义符。例如， ‘n’ 匹配字符 ‘n’。’\\n’ 匹配换行符。序列 ‘\\‘ 匹配 “\\”，而 ‘(‘ 则匹配 “(“。 |<br>| ^        | 匹配输入字符串的开始位置，除非在方括号表达式中使用，此时它表示不接受该字符集合。要匹配 ^ 字符本身，请使用 \\^。 |<br>| {        | 标记限定符表达式的开始。要匹配 {，请使用 {。                |<br>| |       | 指明两项之间的一个选择。要匹配 |，请使用 |。               |</p>\n</li>\n<li><p>限定符</p>\n<p>用来指定正则表达式的一个给定组件必须要出现多少次才能满足匹配,出现在范围表达式之后</p>\n<p>应用于整个范围表达式</p>\n<p>| 字符  | 描述                                                         |<br>| —– | ———————————————————— |<br>| <em>     | 匹配前面的子表达式零次或多次。例如，zo</em> 能匹配 “z” 以及 “zoo”。<em> 等价于{0,}。 |<br>| +     | 匹配前面的子表达式一次或多次。例如，’zo+’ 能匹配 “zo” 以及 “zoo”，但不能匹配 “z”。+ 等价于 {1,}。 |<br>| ?     | 匹配前面的子表达式零次或一次。例如，”do(es)?” 可以匹配 “do” 、 “does” 中的 “does” 、 “doxy” 中的 “do” 。? 等价于 {0,1}。 |<br>| {n}   | n 是一个非负整数。匹配确定的 n 次。例如，’o{2}’ 不能匹配 “Bob” 中的 ‘o’，但是能匹配 “food” 中的两个 o。 |<br>| {n,}  | n 是一个非负整数。至少匹配n 次。例如，’o{2,}’ 不能匹配 “Bob” 中的 ‘o’，但能匹配 “foooood” 中的所有 o。’o{1,}’ 等价于 ‘o+’。’o{0,}’ 则等价于 ‘o</em>‘。 |<br>| {n,m} | m 和 n 均为非负整数，其中n &lt;= m。最少匹配 n 次且最多匹配 m 次。例如，”o{1,3}” 将匹配 “fooooood” 中的前三个 o。’o{0,1}’ 等价于 ‘o?’。请注意在逗号和两个数之间不能有空格。 |</p>\n</li>\n<li><p>定位符</p>\n<p>将正则表达式固定到行首或行尾</p>\n<p>创建出现在一个单词内、在一个单词的开头或者一个单词的结尾的正则表达式</p>\n<p>定位符用来描述字符串或单词的边界</p>\n<p>| 字符 | 描述                                                         |<br>| —- | ———————————————————— |<br>| ^    | 匹配输入字符串开始的位置。如果设置了 RegExp 对象的 Multiline 属性，^ 还会与 \\n 或 \\r 之后的位置匹配。 |<br>| $    | 匹配输入字符串结尾的位置。如果设置了 RegExp 对象的 Multiline 属性，$ 还会与 \\n 或 \\r 之前的位置匹配。 |<br>| \\b   | 匹配一个字边界，即字与空格间的位置。                         |<br>| \\B   | 非字边界匹配。                                               |</p>\n<p>不能将限定符与定位符一起使用。由于在紧靠换行或者字边界的前面或后面不能有一个以上位置，因此不允许诸如 ^* 之类的表达式。</p>\n<p>若要匹配一行文本开始处的文本，请在正则表达式的开始使用 ^ 字符。不要将 ^ 的这种用法与中括号表达式内的用法混淆。</p>\n<p>若要匹配一行文本的结束处的文本，请在正则表达式的结束处使用 $ 字符</p>\n</li>\n<li><p>选择</p>\n<p>用圆括号将所有选择项括起来，相邻的选择项之间用|分隔。但用圆括号会有一个副作用，使相关的匹配会被缓存，此时可用?:放在第一个选项前来消除这种副作用。</p>\n<p>其中 ?: 是非捕获元之一，还有两个非捕获元是 ?= 和 ?!，这两个还有更多的含义，前者为正向预查，在任何开始匹配圆括号内的正则表达式模式的位置来匹配搜索字符串，后者为负向预查，在任何开始不匹配该正则表达式模式的位置来匹配搜索字符串。</p>\n</li>\n<li><p>反向引用</p>\n<p>对一个正则表达式模式或部分模式两边添加圆括号将导致相关匹配存储到一个临时缓冲区中，所捕获的每个子匹配都按照在正则表达式模式中从左到右出现的顺序存储。缓冲区编号从 1 开始，最多可存储 99 个捕获的子表达式。每个缓冲区都可以使用 \\n 访问，其中 n 为一个标识特定缓冲区的一位或两位十进制数。</p>\n<p>可以使用非捕获元字符 ?:、?= 或 ?! 来重写捕获，忽略对相关匹配的保存。</p>\n<p>反向引用的最简单的、最有用的应用之一，是提供查找文本中两个相同的相邻单词的匹配项的能力</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>元字符</p>\n<p>| 字符         | 描述                                                         |<br>| ———— | ———————————————————— |<br>| \\            | 将下一个字符标记为一个特殊字符、或一个原义字符、或一个 向后引用、或一个八进制转义符。例如，’n’ 匹配字符 “n”。’\\n’ 匹配一个换行符。序列 ‘\\‘ 匹配 “\\” 而 “(“ 则匹配 “(“。 |<br>| ^            | 匹配输入字符串的开始位置。如果设置了 RegExp 对象的 Multiline 属性，^ 也匹配 ‘\\n’ 或 ‘\\r’ 之后的位置。 |<br>| $            | 匹配输入字符串的结束位置。如果设置了RegExp 对象的 Multiline 属性，$ 也匹配 ‘\\n’ 或 ‘\\r’ 之前的位置。 |<br>| <em>            | 匹配前面的子表达式零次或多次。例如，zo</em> 能匹配 “z” 以及 “zoo”。<em> 等价于{0,}。 |<br>| +            | 匹配前面的子表达式一次或多次。例如，’zo+’ 能匹配 “zo” 以及 “zoo”，但不能匹配 “z”。+ 等价于 {1,}。 |<br>| ?            | 匹配前面的子表达式零次或一次。例如，”do(es)?” 可以匹配 “do” 或 “does” 。? 等价于 {0,1}。 |<br>| {n}          | n 是一个非负整数。匹配确定的 n 次。例如，’o{2}’ 不能匹配 “Bob” 中的 ‘o’，但是能匹配 “food” 中的两个 o。 |<br>| {n,}         | n 是一个非负整数。至少匹配n 次。例如，’o{2,}’ 不能匹配 “Bob” 中的 ‘o’，但能匹配 “foooood” 中的所有 o。’o{1,}’ 等价于 ‘o+’。’o{0,}’ 则等价于 ‘o</em>‘。 |<br>| {n,m}        | m 和 n 均为非负整数，其中n &lt;= m。最少匹配 n 次且最多匹配 m 次。例如，”o{1,3}” 将匹配 “fooooood” 中的前三个 o。’o{0,1}’ 等价于 ‘o?’。请注意在逗号和两个数之间不能有空格。 |<br>| ?            | 当该字符紧跟在任何一个其他限制符 (*, +, ?, {n}, {n,}, {n,m}) 后面时，匹配模式是非贪婪的。非贪婪模式尽可能少的匹配所搜索的字符串，而默认的贪婪模式则尽可能多的匹配所搜索的字符串。例如，对于字符串 “oooo”，’o+?’ 将匹配单个 “o”，而 ‘o+’ 将匹配所有 ‘o’。 |<br>| .            | 匹配除换行符（\\n、\\r）之外的任何单个字符。要匹配包括 ‘\\n’ 在内的任何字符，请使用像”<strong>(.|\\n)</strong>“的模式。 |<br>| (pattern)    | 匹配 pattern 并获取这一匹配。所获取的匹配可以从产生的 Matches 集合得到，在VBScript 中使用 SubMatches 集合，在JScript 中则使用 $0…$9 属性。要匹配圆括号字符，请使用 ‘(‘ 或 ‘)‘。 |<br>| (?:pattern)  | 匹配 pattern 但不获取匹配结果，也就是说这是一个非获取匹配，不进行存储供以后使用。这在使用 “或” 字符 (|) 来组合一个模式的各个部分是很有用。例如， ‘industr(?:y|ies) 就是一个比 ‘industry|industries’ 更简略的表达式。 |<br>| (?=pattern)  | 正向肯定预查（look ahead positive assert），在任何匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如，”Windows(?=95|98|NT|2000)”能匹配”Windows2000”中的”Windows”，但不能匹配”Windows3.1”中的”Windows”。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。 |<br>| (?!pattern)  | 正向否定预查(negative assert)，在任何不匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如”Windows(?!95|98|NT|2000)”能匹配”Windows3.1”中的”Windows”，但不能匹配”Windows2000”中的”Windows”。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。 |<br>| (?&lt;=pattern) | 反向(look behind)肯定预查，与正向肯定预查类似，只是方向相反。例如，”<code>(?&lt;=95|98|NT|2000)Windows</code>“能匹配”<code>2000Windows</code>“中的”<code>Windows</code>“，但不能匹配”<code>3.1Windows</code>“中的”<code>Windows</code>“。 |<br>| (?&lt;!pattern) | 反向否定预查，与正向否定预查类似，只是方向相反。例如”<code>(?&lt;!95|98|NT|2000)Windows</code>“能匹配”<code>3.1Windows</code>“中的”<code>Windows</code>“，但不能匹配”<code>2000Windows</code>“中的”<code>Windows</code>“。 |<br>| x|y         | 匹配 x 或 y。例如，’z|food’ 能匹配 “z” 或 “food”。’(z|f)ood’ 则匹配 “zood” 或 “food”。 |<br>| [xyz]        | 字符集合。匹配所包含的任意一个字符。例如， ‘[abc]’ 可以匹配 “plain” 中的 ‘a’。 |<br>| [^xyz]       | 负值字符集合。匹配未包含的任意字符。例如， ‘[^abc]’ 可以匹配 “plain” 中的’p’、’l’、’i’、’n’。 |<br>| [a-z]        | 字符范围。匹配指定范围内的任意字符。例如，’[a-z]’ 可以匹配 ‘a’ 到 ‘z’ 范围内的任意小写字母字符。 |<br>| [^a-z]       | 负值字符范围。匹配任何不在指定范围内的任意字符。例如，’[^a-z]’ 可以匹配任何不在 ‘a’ 到 ‘z’ 范围内的任意字符。 |<br>| \\b           | 匹配一个单词边界，也就是指单词和空格间的位置。例如， ‘er\\b’ 可以匹配”never” 中的 ‘er’，但不能匹配 “verb” 中的 ‘er’。 |<br>| \\B           | 匹配非单词边界。’er\\B’ 能匹配 “verb” 中的 ‘er’，但不能匹配 “never” 中的 ‘er’。 |<br>| \\cx          | 匹配由 x 指明的控制字符。例如， \\cM 匹配一个 Control-M 或回车符。x 的值必须为 A-Z 或 a-z 之一。否则，将 c 视为一个原义的 ‘c’ 字符。 |<br>| \\d           | 匹配一个数字字符。等价于 [0-9]。                             |<br>| \\D           | 匹配一个非数字字符。等价于 [^0-9]。                          |<br>| \\f           | 匹配一个换页符。等价于 \\x0c 和 \\cL。                         |<br>| \\n           | 匹配一个换行符。等价于 \\x0a 和 \\cJ。                         |<br>| \\r           | 匹配一个回车符。等价于 \\x0d 和 \\cM。                         |<br>| \\s           | 匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ \\f\\n\\r\\t\\v]。 |<br>| \\S           | 匹配任何非空白字符。等价于 [^ \\f\\n\\r\\t\\v]。                  |<br>| \\t           | 匹配一个制表符。等价于 \\x09 和 \\cI。                         |<br>| \\v           | 匹配一个垂直制表符。等价于 \\x0b 和 \\cK。                     |<br>| \\w           | 匹配字母、数字、下划线。等价于’[A-Za-z0-9_]’。               |<br>| \\W           | 匹配非字母、数字、下划线。等价于 ‘[^A-Za-z0-9_]’。           |<br>| \\xn          | 匹配 n，其中 n 为十六进制转义值。十六进制转义值必须为确定的两个数字长。例如，’\\x41’ 匹配 “A”。’\\x041’ 则等价于 ‘\\x04’ &amp; “1”。正则表达式中可以使用 ASCII 编码。 |<br>| \\num         | 匹配 num，其中 num 是一个正整数。对所获取的匹配的引用。例如，’(.)\\1’ 匹配两个连续的相同字符。 |<br>| \\n           | 标识一个八进制转义值或一个向后引用。如果 \\n 之前至少 n 个获取的子表达式，则 n 为向后引用。否则，如果 n 为八进制数字 (0-7)，则 n 为一个八进制转义值。 |<br>| \\nm          | 标识一个八进制转义值或一个向后引用。如果 \\nm 之前至少有 nm 个获得子表达式，则 nm 为向后引用。如果 \\nm 之前至少有 n 个获取，则 n 为一个后跟文字 m 的向后引用。如果前面的条件都不满足，若 n 和 m 均为八进制数字 (0-7)，则 \\nm 将匹配八进制转义值 nm。 |<br>| \\nml         | 如果 n 为八进制数字 (0-3)，且 m 和 l 均为八进制数字 (0-7)，则匹配八进制转义值 nml。 |<br>| \\un          | 匹配 n，其中 n 是一个用四个十六进制数字表示的 Unicode 字符。例如， \\u00A9 匹配版权符号 (?)。 |</p>\n</li>\n</ul>\n</li>\n<li><p>运算符优先级</p>\n<p>正则表达式从左到右进行计算，并遵循优先级顺序，这与算术表达式非常类似。</p>\n<p>相同优先级的从左到右进行运算，不同优先级的运算先高后低。下表从最高到最低说明了各种正则表达式运算符的优先级顺序：</p>\n<p>| 运算符                      | 描述                                                         |<br>| ————————— | ———————————————————— |<br>| \\                           | 转义符                                                       |<br>| (), (?:), (?=), []          | 圆括号和方括号                                               |<br>| *, +, ?, {n}, {n,}, {n,m}   | 限定符                                                       |<br>| ^, $, \\任何元字符、任何字符 | 定位点和序列（即：位置和顺序）                               |<br>| |                          | 替换，”或”操作 字符具有高于替换运算符的优先级，使得”m|food”匹配”m”或”food”。若要匹配”mood”或”food”，请使用括号创建子表达式，从而产生”(m|f)ood”。 |</p>\n</li>\n<li><p>匹配规则</p>\n</li>\n</ul>\n","categories":["我爱学习"],"tags":["日常学习","日常"]},{"title":"每日学习笔记(2018.8.22)","url":"https://yixiaoer.github.io/2018/08/22/日常学习笔记(2018.8.22)/","content":"<p><strong>每日学习笔记</strong><br>Web学习相关内容<br>前端后端学习记录/学习笔记<br>为C课设的学习准备<br>大部分都只是所看的记录<br><em>2018.8.22</em> C课设;《Go Web》与gin框架</p>\n<h1 id=\"关于Go标准命令行\"><a href=\"#关于Go标准命令行\" class=\"headerlink\" title=\"关于Go标准命令行\"></a>关于Go标准命令行</h1><p>参考<a href=\"https://github.com/hyper0x/go_command_tutorial/blob/master/SUMMARY.md\" target=\"_blank\" rel=\"noopener\">《Go命令教程》</a>及[《Go Web》中的Go命令部分(<a href=\"https://wizardforcel.gitbooks.io/build-web-application-with-golang/content/01.3.html\" target=\"_blank\" rel=\"noopener\">https://wizardforcel.gitbooks.io/build-web-application-with-golang/content/01.3.html</a>)</p>\n<p>关于Go的部分命令</p>\n<h2 id=\"go-bulid\"><a href=\"#go-bulid\" class=\"headerlink\" title=\"go bulid\"></a>go bulid</h2><ul>\n<li><p><code>go build</code>命令用于编译我们指定的源码文件或代码包以及它们的依赖包</p>\n</li>\n<li><p>如果在执行该命令时不后跟任何代码包,则命令将试图编译当前目录所对应的代码包</p>\n</li>\n<li><p><code>go bulid</code>命令的常用标记</p>\n<p>| 标记名称 | 标记描述                                                     |<br>| ——– | ———————————————————— |<br>| -a       | 强行对所有涉及到的代码包（包含标准库中的代码包）进行重新构建，即使它们已经是最新的了。 |<br>| -n       | 打印编译期间所用到的其它命令，但是并不真正执行它们。         |<br>| -p n     | 指定编译过程中执行各任务的并行数量（确切地说应该是并发数量）。在默认情况下，该数量等于CPU的逻辑核数。但是在<code>darwin/arm</code>平台（即iPhone和iPad所用的平台）下，该数量默认是<code>1</code>。 |<br>| -race    | 开启竞态条件的检测。不过此标记目前仅在<code>linux/amd64</code>、<code>freebsd/amd64</code>、<code>darwin/amd64</code>和<code>windows/amd64</code>平台下受到支持。 |<br>| -v       | 打印出那些被编译的代码包的名字。                             |<br>| -work    | 打印出编译时生成的临时工作目录的路径，并在编译结束时保留它。在默认情况下，编译结束时会删除该目录。 |<br>| -x       | 打印编译期间所用到的其它命令。注意它与<code>-n</code>标记的区别。       |</p>\n</li>\n<li><p>从代码包编译的角度来说,如果代码包A依赖代码包B,则称代码包B时代码包A的依赖代码包(简称依赖包)</p>\n</li>\n<li><p>关于Go语言的源码文件</p>\n<ul>\n<li>库源码文件:一般用于集中放置各种待被使用的程序实体(eg.全局常量、全局变量、接口、结构体、函数etc.)</li>\n<li><p>测试源码文件:主要用于对前两种源码文件中的程序实体的功能和性能进行测试,也可以用于展示前两者中程序的使用方法</p>\n</li>\n<li><p>命令源码文件:一般总是作为可执行的程序的入口</p>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"go-install\"><a href=\"#go-install\" class=\"headerlink\" title=\"go install\"></a>go install</h2><ul>\n<li><code>go install</code>命令用于编译并安装指定的代码包及它们的依赖包</li>\n<li><code>go install</code>比<code>go bulid</code>只多做了一件事,即安装编译后的结果文件到指定目录</li>\n</ul>\n<h2 id=\"go-get\"><a href=\"#go-get\" class=\"headerlink\" title=\"go get\"></a>go get</h2><ul>\n<li><code>go get</code>命令可以根据要求和实际情况从互联网上下载或更新指定的代码包及其依赖包，并对它们进行编译和安装</li>\n</ul>\n<h2 id=\"go-clean\"><a href=\"#go-clean\" class=\"headerlink\" title=\"go clean\"></a>go clean</h2><ul>\n<li><code>go clean</code>命令会删除掉执行其它命令时产生的一些文件和目录</li>\n</ul>\n<h2 id=\"go-env\"><a href=\"#go-env\" class=\"headerlink\" title=\"go env\"></a>go env</h2><ul>\n<li><p><code>go env</code>命令用于打印 Go 语言的环境信息</p>\n</li>\n<li><p>打印出的这些信息</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>名称</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>CGO_ENABLED</td>\n<td>指明cgo工具是否可用的标识</td>\n</tr>\n<tr>\n<td>GOARCH</td>\n<td>程序构建环境的目标计算架构</td>\n</tr>\n<tr>\n<td>GOBIN</td>\n<td>存放可执行文件的目录的绝对路径</td>\n</tr>\n<tr>\n<td>GOCHAR</td>\n<td>程序构建环境的目标计算架构的单字符标识</td>\n</tr>\n<tr>\n<td>GOEXE</td>\n<td>可执行文件的后缀</td>\n</tr>\n<tr>\n<td>GOHOSTARCH</td>\n<td>程序运行环境的目标计算架构</td>\n</tr>\n<tr>\n<td>GOOS</td>\n<td>程序构建环境的目标操作系统</td>\n</tr>\n<tr>\n<td>GOHOSTOS</td>\n<td>程序运行环境的目标操作系统</td>\n</tr>\n<tr>\n<td>GOPATH</td>\n<td>工作区目录的绝对路径</td>\n</tr>\n<tr>\n<td>GORACE</td>\n<td>用于数据竞争检测的相关选项</td>\n</tr>\n<tr>\n<td>GOROOT</td>\n<td>Go语言的安装目录的绝对路径</td>\n</tr>\n<tr>\n<td>GOTOOLDIR</td>\n<td>Go工具目录的绝对路径</td>\n</tr>\n</tbody>\n</table>\n<h1 id=\"《Go-Web》\"><a href=\"#《Go-Web》\" class=\"headerlink\" title=\"《Go Web》\"></a>《Go Web》</h1><ul>\n<li><p>再次关于GOPATH</p>\n<ul>\n<li><p>GOPATH允许多个目录</p>\n</li>\n<li><p>$GOPATH目录约定有三个子目录,src目录是开发程序的主要目录</p>\n</li>\n<li>package的名称建议与目录名保持一致</li>\n</ul>\n</li>\n<li><p>静态语言</p>\n<p>P.S.关于<a href=\"https://zh.wikipedia.org/wiki/%E9%A1%9E%E5%9E%8B%E7%B3%BB%E7%B5%B1\" target=\"_blank\" rel=\"noopener\">类型系统</a></p>\n<ul>\n<li>类型系统用于定义如何将编程语言的数值和表达式归类为许多不同的类型,如何操作这些类型,这些类型如何互相作用</li>\n<li>类型的约束程度以及评估方法,影响了语言的类型;更进一步,编程语言可能就类型多态性部分,对每一个类型都对应了一个极度个别的算法的运算</li>\n<li>类型检查所进行的检验处理以及实行类型的约束,可发生在编译时期(<strong>静态检查</strong>)或运行时期(<strong>动态检查</strong>),静态类型检查是在编译器所进行语义分析中进行的</li>\n<li>如果一个语言强制实行类型规则(即通常只允许以不丢失信息为前提的自动类型转换)就称此处理为<strong>强类型</strong>，反之称为<strong>弱类型</strong></li>\n<li>如果一个编程语言的类型检查,可在不测试运行时期表达式的等价性的情况下进行,该语言即为<strong>静态类型</strong>的,一个静态类型的编程语言,是在运行时期和编译时期之间的处理阶段下重视这些区别的</li>\n<li>如果程序的独立模块,可进行各自的类型检查(独立编译),而无须所有会在运行时出现的模块的那些信息,该语言即具有一个编译时期阶段</li>\n<li>如果一个编程语言支持运行时期(动态)调度已标记的数据,该语言即为<strong>动态类型</strong>的</li>\n<li>如果一个编程语言破坏了阶段的区别,因而类型检查需要测试运行时期的表达式的等价性,该语言即为<strong>依存类型</strong>的</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li><p>垃圾回收型语言</p>\n<p>垃圾回收(Garbage Collection,GC)在计算机科学中是一种自动的存储器管理机制,当一个计算机上的动态存储器不再需要时,就予以释放,以让出存储器,这种存储器资源管理,称为垃圾回收</p>\n<p>其<a href=\"https://making.pusher.com/golangs-real-time-gc-in-theory-and-practice/\" target=\"_blank\" rel=\"noopener\">垃圾回收理论与实例</a>及<a href=\"https://gocn.vip/article/192\" target=\"_blank\" rel=\"noopener\">中文翻译</a></p>\n</li>\n<li><p>在安装Go的时候需要设置GOPATH变量,且不能和Go的安装目录一样,这个目录用来存放Go源码、Go的可运行文件,以及相应的编译之后的包文件,这个目录下面有三个子目录：src、bin、pkg</p>\n<ul>\n<li><strong>src</strong> 存放源代码(eg.<code>.go</code>,<code>.c</code>,<code>.h</code>,<code>.s</code>,etc.),是接下来开发程序的主要目录,所有的源码都是放在这个目录下面,一般一个目录一个项目</li>\n<li><strong>pkg</strong>存放编译后生成的文件（eg.<code>.a</code>,etc.）</li>\n<li><strong>bin</strong>存放编译后生成的可执行文件(为了方便,可把此目录加入到 $PATH 变量中,如果有多个gopath,则使用<code>${GOPATH//://bin:}/bin</code>添加所有的bin目录）</li>\n</ul>\n</li>\n<li><p>一些语法</p>\n<ul>\n<li><p>多行字符串用<code></code> `来声明,括起的字符串为Raw字符串,即字符串在代码中的形式就是打印时的形式没有字符转义，换行也将原样输出</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">m := <span class=\"string\">`hello</span></span><br><span class=\"line\"><span class=\"string\">    world`</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>Go里面有两个保留的函数：<code>init</code>函数(能够应用于所有的<code>package</code>)和<code>main</code>函数(只能应用于<code>package main</code>),Go程序会自动调用<code>init()</code>和<code>main()</code>,所以不需要在任何地方调用这两个函数。每个<code>package</code>中的<code>init</code>函数都是可选的，但<code>package main</code>就必须包含一个<code>main</code>函数</p>\n</li>\n<li><p><code>method</code> 带有接收者的函数</p>\n<blockquote>\n<p>“A method is a function with an implicit first argument, called a receiver.”</p>\n</blockquote>\n<ul>\n<li><code>method</code>可以定义在任何自定义的类型、内置类型、struct等各种类型上面</li>\n</ul>\n</li>\n<li><p><code>interface</code></p>\n</li>\n<li><p>并发</p>\n</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h1><ul>\n<li><p>关于SDK</p>\n<ul>\n<li>Software Development Kit,SDK</li>\n<li>一般是一些用于为特定的软件包、软件框架、硬件平台、操作系统等创建应用软件的一些开发工具的集合</li>\n<li>和API的区别<ul>\n<li>API就是一个接口,任何知道如何使用这个接口的都可以去直接运用</li>\n<li>SDK由一些工具组成,可能可以包含一些API</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>VScode关于go语言的一些配置</p>\n<ul>\n<li><p>GOPATH路径改变</p>\n</li>\n<li><p>解决几个go插件的安装</p>\n<ul>\n<li><p>在vscode里下载不成功</p>\n<ul>\n<li><p>打开<code>%GOPATH%/src/golang.org/x</code></p>\n</li>\n<li><p>下载插件包</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git clone https://github.com/golang/tools.git tools</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>重新进入进入“%GOPATH”目录,依次执行</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">go install github.com/ramya-rao-a/go-outline</span><br><span class=\"line\"></span><br><span class=\"line\">go install github.com/acroca/go-symbols</span><br><span class=\"line\"></span><br><span class=\"line\">go install golang.org/x/tools/cmd/guru</span><br><span class=\"line\"></span><br><span class=\"line\">go install golang.org/x/tools/cmd/gorename</span><br><span class=\"line\"></span><br><span class=\"line\">go install github.com/josharian/impl</span><br><span class=\"line\"></span><br><span class=\"line\">go install github.com/rogpeppe/godef</span><br><span class=\"line\"></span><br><span class=\"line\">go install github.com/sqs/goreturns</span><br><span class=\"line\"></span><br><span class=\"line\">go install github.com/golang/lint/golint</span><br><span class=\"line\"></span><br><span class=\"line\">go install github.com/cweill/gotests/gotests</span><br><span class=\"line\"></span><br><span class=\"line\">go install github.com/ramya-rao-a/go-outline</span><br><span class=\"line\"></span><br><span class=\"line\">go install github.com/acroca/go-symbols</span><br><span class=\"line\"></span><br><span class=\"line\">go install golang.org/x/tools/cmd/guru</span><br><span class=\"line\"></span><br><span class=\"line\">go install golang.org/x/tools/cmd/gorename</span><br><span class=\"line\"></span><br><span class=\"line\">go install github.com/josharian/impl</span><br><span class=\"line\"></span><br><span class=\"line\">go install github.com/rogpeppe/godef</span><br><span class=\"line\"></span><br><span class=\"line\">go install github.com/sqs/goreturns</span><br><span class=\"line\"></span><br><span class=\"line\">go install github.com/golang/lint/golint</span><br><span class=\"line\"></span><br><span class=\"line\">go install github.com/cweill/gotests/gotests</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>如果遇到<code>cannot find package</code></p>\n<p>先<code>git clone https://github.com/golang/xxxxxxxxxxxxx</code>复制其到<code>%GOPATH%\\src\\golang.org\\x</code>目录下或者<code>go get -u github.com/xxxxxxxxxxx</code></p>\n<p>再执行<code>go install xxxxxxxx</code> </p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>gin框架</p>\n<ul>\n<li>Download and install it:</li>\n</ul>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> go get -u github.com/gin-gonic/gin</span></span><br></pre></td></tr></table></figure>\n<pre><code>Import it in your code:\n</code></pre><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">\"github.com/gin-gonic/gin\"</span></span><br></pre></td></tr></table></figure>\n<pre><code>(Optional) Import `net/http`. This is required for example if using constants such as `http.StatusOK`\n</code></pre><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">\"net/http\"</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>use vendor<code>govendor</code><ul>\n<li>go get` govendor</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ go get github.com/kardianos/govendor</span><br></pre></td></tr></table></figure>\n<ul>\n<li><ul>\n<li>Create your project folder and <code>cd</code> inside</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ mkdir -p $GOPATH/src/github.com/myusername/project &amp;&amp; cd &quot;$_&quot;</span><br></pre></td></tr></table></figure>\n<ul>\n<li><ul>\n<li>Vendor init your project and add gin</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ govendor init</span><br><span class=\"line\">$ govendor fetch github.com/gin-gonic/gin@v1.3</span><br></pre></td></tr></table></figure>\n<ul>\n<li><ul>\n<li>Copy a starting template inside your project</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ curl https://raw.githubusercontent.com/gin-gonic/gin/master/examples/basic/main.go &gt; main.go</span><br></pre></td></tr></table></figure>\n<ul>\n<li><ul>\n<li>Run your project</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ go run main.go</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n","categories":["我爱学习"],"tags":["日常学习","日常"]},{"title":"每日学习笔记(2018.8.20)","url":"https://yixiaoer.github.io/2018/08/20/日常学习笔记(2018.8.20)/","content":"<p><strong>每日学习笔记</strong><br>Web学习相关内容<br>前端后端学习记录/学习笔记<br>为C课设的学习准备<br>大部分都只是所看的记录<br><em>2018.8.20</em> C课设准备;《Go Web》与gin框架</p>\n<h1 id=\"网络基础\"><a href=\"#网络基础\" class=\"headerlink\" title=\"网络基础\"></a>网络基础</h1><h2 id=\"网络热点技术\"><a href=\"#网络热点技术\" class=\"headerlink\" title=\"网络热点技术\"></a>网络热点技术</h2><h3 id=\"云计算-cloud-computing\"><a href=\"#云计算-cloud-computing\" class=\"headerlink\" title=\"云计算(cloud computing)\"></a>云计算(cloud computing)</h3><ul>\n<li>是一种基于互联网的计算方式,通过这种方式,共享的软硬件资源和信息可以按需求提供给计算机各种终端和其他设备,将集群计算能力通过互联网向内外部用户提供服务的互联网新业务</li>\n<li>云计算依赖资源的共享以达成规模经济</li>\n<li>云计算服务应该具备以下几条特征:<ul>\n<li>随需应变自助服务</li>\n<li>随时随地用任何网络设备访问</li>\n<li>多人共享资源池</li>\n<li>快速重新部署灵活度</li>\n<li>可被监控与量测的服务</li>\n<li>基于虚拟化技术快速部署资源或获得服务</li>\n<li>减少用户终端的处理负担</li>\n<li>降低了用户对于IT专业知识的依赖</li>\n</ul>\n</li>\n<li>三种服务模式:<ul>\n<li>“软件即服务,<a href=\"https://zh.wikipedia.org/wiki/%E8%BD%AF%E4%BB%B6%E5%8D%B3%E6%9C%8D%E5%8A%A1\" target=\"_blank\" rel=\"noopener\">SaaS</a>“,消费者使用应用程序,但并不掌控操作系统、硬件或运作的网络基础架构。是一种服务观念的基础,软件服务供应商,以租赁的概念提供客户服务,而非购买,比较常见的模式是提供一组账号密码</li>\n<li>“平台即服务,<a href=\"https://zh.wikipedia.org/wiki/%E5%B9%B3%E5%8F%B0%E5%8D%B3%E6%9C%8D%E5%8A%A1\" target=\"_blank\" rel=\"noopener\">PaaS</a>“,消费者使用主机操作应用程序。消费者掌控运作应用程序的环境（也拥有主机部分掌控权），但并不掌控操作系统、硬件或运作的网络基础架构。平台通常是应用程序基础架构。</li>\n<li>“基础设施即服务,<a href=\"https://zh.wikipedia.org/wiki/%E5%9F%BA%E7%A4%8E%E8%A8%AD%E6%96%BD%E5%8D%B3%E6%9C%8D%E5%8B%99\" target=\"_blank\" rel=\"noopener\">laaS</a>“,消费者使用“基础计算资源”,如处理能力、存储空间、网络组件或中间件。消费者能掌控操作系统、存储空间、已部署的应用程序及网络组件(如防火墙、负载平衡器等),但并不掌控云基础架构</li>\n</ul>\n</li>\n<li>一些云计算应用<ul>\n<li>云储存是在云计算概念上延伸和发展出来的一个新概念,指通过集群应用、网格技术或分布式文件系统等功能,将网络中大量各种不同类型的储存设备通过应用软件集合起来协同工作,共同对外提供数据储存和业务访问功能的一个系统</li>\n<li>云物联</li>\n<li>云教育</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"物联网\"><a href=\"#物联网\" class=\"headerlink\" title=\"物联网\"></a>物联网</h3><ul>\n<li>Internet of Things,IoT,即物物相连的互联网</li>\n<li>是互联网、传统电信网等信息承载体,让所有能行使独立功能的普通物体实现互联互通的网络</li>\n<li>把感应器嵌入生活相关的物品中,就能实现智能生活</li>\n</ul>\n<h3 id=\"对等网络\"><a href=\"#对等网络\" class=\"headerlink\" title=\"对等网络\"></a>对等网络</h3><ul>\n<li>Peer to Peer,P2P,点对点技术</li>\n<li>是无中心服务器、依靠用户群(peers)交换信息的互联网体系</li>\n<li>作用是减低以往网路传输中的节点,以降低资料遗失的风险</li>\n<li>与有中心服务器的中央网络系统不同,对等网络的每个用户端既是一个节点,也有服务器的功能,任何一个节点无法直接找到其他节点,必须依靠其户群进行信息交流</li>\n</ul>\n<h2 id=\"网络\"><a href=\"#网络\" class=\"headerlink\" title=\"网络\"></a>网络</h2><h3 id=\"关于网络\"><a href=\"#关于网络\" class=\"headerlink\" title=\"关于网络\"></a>关于网络</h3><ul>\n<li>是利用通信设备和线路将地理位置不同的、功能独立的多个计算机系统连接起来,以功能完善的网络软件实现网络的硬件、软件及资源共享和信息传递的系统,简单说来,即连接两台或多台计算机进行通信的系统</li>\n<li>联网计算机之间通信必须遵循共同的网络协议</li>\n<li>按地理范围的大小分类网络<ul>\n<li>局域网</li>\n<li>城域网</li>\n<li>广域网</li>\n<li>互联网</li>\n</ul>\n</li>\n</ul>\n<p>又是什么没做的懒惰的一天QAQ</p>\n","categories":["我爱学习"],"tags":["日常学习","日常"]},{"title":"日本之行","url":"https://yixiaoer.github.io/2018/08/20/日本之行/","content":"<p><strong>日本之行</strong></p>\n<h1 id=\"准备\"><a href=\"#准备\" class=\"headerlink\" title=\"准备\"></a>准备</h1><ul>\n<li>交通(占出行开销的很大一部分,而且交通网络复杂)</li>\n<li>住宿</li>\n<li>兑换日元(必须花现金的地方还是很多的)</li>\n<li>列好购物list(可以有针对性的逛街,找好商店及区域)</li>\n</ul>\n<h1 id=\"出行\"><a href=\"#出行\" class=\"headerlink\" title=\"出行\"></a>出行</h1><ul>\n<li>第一天刚下飞机，遇到一位非常友善的日本大叔，他用英语极力向我们大概介绍了一下交通，并在沿途向我们介绍了周围的环境，向我们表示欢迎</li>\n<li>大阪民宿旁买章鱼烧的大叔特别热情</li>\n<li>便利店店员也是，但是日复一日这样用力对他人欢笑，会不会觉得很累会不会感觉工作压力十足呢</li>\n<li>地铁很安静，大多数人没有笑容也并不活泼，学生们倒是挺热闹的，我们6个人也是</li>\n<li>售房广告词和国内差不多啊，都是什么地铁口公园旁之类的</li>\n<li>在请勿停放自行车的牌子下面还是停了一辆自行车</li>\n<li>垃圾分类加上路上没有垃圾桶</li>\n<li>商场关门太早了，总有种购物刚刚开始就要结束的感觉</li>\n<li>关西左行右立，关东左立右行，但有时候指示牌又不是这样，有点迷啊，还是浜松最舒服，规矩没这么多(而且还是日本幸福度最高的地区,所以…)     </li>\n<li>从环球影城回民宿，坐车坐错了，在车上讨论，六脸对视懵逼，有人主动上前告诉我们怎么换乘</li>\n<li>地铁上看书的人更多</li>\n<li>人更精致</li>\n<li>简直潮男天堂，卖的男装真的风格多样，而且款式很好看，同行男生也真的很能逛</li>\n<li>东京实在是太繁华了，果然大都市大都市</li>\n<li>奔赴晴空塔之跑，真的很棒真值呢</li>\n<li>镰仓太美太舒服了</li>\n</ul>\n<h1 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h1><ul>\n<li>一起出行的人真的对于出行质量很重要</li>\n<li>多拍照片吖,真是太有意思了</li>\n<li>少蔬果真的很要命</li>\n<li>做饭方式太单一了,还没有热热闹闹的过早,基本上都是冰水,真的很绝望!</li>\n<li>拥抱国内物价</li>\n<li>我们有一天真的受不了了,终于找到一家中华料理,炒菜真的太好了啊</li>\n<li>回来吃火锅我真的高兴疯了,吃了好多好多!大概是吃的最多的!有了对比,火锅带来的幸福感一下子到了最大！</li>\n<li>服务态度实在太好了,无论是购物还是日常的出行都非常舒服</li>\n<li>自动门!!!一万个好评,即使不得不说第一顿吃火锅很开心!但那家火锅店不是自动门让我竟然有些失落</li>\n<li>卫生间真的很棒,忽然很理解那些要带马桶盖回国的人</li>\n<li>体验了日剧跑,而且真的跑的好累啊,但很值得呢!不奔跑永远不知道来不来得及!(唉,的士实在太贵了,还没有无处不在的滴滴)</li>\n<li>地铁的台阶太多了QAQ每天爬上爬下真的好累..尤其是拎着行李箱的时候</li>\n<li>回国飞上海,在那里又玩了一下,这服务态度真的和日本天差地别..有了对比就有了伤害,一下子还有点不适应…</li>\n</ul>\n<h1 id=\"后续\"><a href=\"#后续\" class=\"headerlink\" title=\"后续\"></a>后续</h1><ul>\n<li>还是无比怀念啊</li>\n<li>还有好多想记录的没记录啊,所见所想实在太多了</li>\n<li>在日本购物太舒服了</li>\n<li>还有很多没逛到没看到的,有机会一定要再去</li>\n<li>本来想写个抒情的游记，但是变成了不抒情但又逻辑性的莫名其妙奇奇怪怪的记录😂甩锅给markdown（好叭其实更怪我太懒😂</li>\n<li>加个to be continued叭，或许有天心血来潮就开始写抒情游记了🌝</li>\n</ul>\n","categories":["吃喝玩乐"],"tags":["玩乐","出行"]},{"title":"每日学习笔记(2018.8.6)","url":"https://yixiaoer.github.io/2018/08/06/日常学习笔记(2018.8.6)/","content":"<p><strong>每日学习笔记</strong><br>Web学习相关内容<br>前端后端学习记录/学习笔记<br>大部分都只是所看的记录<br><em>2018.8.6</em> github博客;《Go Web》与gin框架</p>\n<h1 id=\"博客的继续配置\"><a href=\"#博客的继续配置\" class=\"headerlink\" title=\"博客的继续配置\"></a>博客的继续配置</h1><h3 id=\"访问量\"><a href=\"#访问量\" class=\"headerlink\" title=\"访问量\"></a>访问量</h3><ul>\n<li><p>在next的配置文件_config.yml中找到footer,添加如下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">footer:</span><br><span class=\"line\">  # -------------------------------------------------------------</span><br><span class=\"line\">  # visitors count</span><br><span class=\"line\">  counter: true</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>在<code>theme/next/layout/_partials/fotter.swig</code>中加入</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;% if theme.footer.counter %&#125;  </span><br><span class=\"line\">&lt;script async src=&quot;//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js&quot;&gt;&lt;/script&gt;    &lt;span id=&quot;busuanzi_container_site_pv&quot;&gt;总访问量&lt;span id=&quot;busuanzi_value_site_pv&quot;&gt;&lt;/span&gt;次&lt;/span&gt;    </span><br><span class=\"line\">&lt;span class=&quot;post-meta-divider&quot;&gt;|&lt;/span&gt;    </span><br><span class=\"line\">&lt;span id=&quot;busuanzi_container_site_uv&quot;&gt;总访客&lt;span id=&quot;busuanzi_value_site_uv&quot;&gt;&lt;/span&gt;人&lt;/span&gt;    </span><br><span class=\"line\">&lt;span class=&quot;post-meta-divider&quot;&gt;|&lt;/span&gt;</span><br><span class=\"line\">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"文末添加本文结束\"><a href=\"#文末添加本文结束\" class=\"headerlink\" title=\"文末添加本文结束\"></a>文末添加本文结束</h3><p>在<code>/themes/next/layout/_macro</code>中新建<code>passage-end-tag.swig</code></p>\n<p>添加</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div&gt;</span><br><span class=\"line\">    &#123;% if not is_index %&#125;</span><br><span class=\"line\">        &lt;div style=&quot;text-align:center;color: #636363;font-size:14px;letter-spacing: 10px&quot;&gt;本文结束&lt;i class=&quot;fa fa-bell&quot;&gt;&lt;/i&gt;感谢阅读&lt;/div&gt;</span><br><span class=\"line\">    &#123;% endif %&#125;</span><br><span class=\"line\">&lt;/div&gt;</span><br></pre></td></tr></table></figure>\n<p>在<code>/themes/next/layout/_macro</code>中<code>post.swig</code>中的end post body之后添加如下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>在主配置文件中添加</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">passage_end_tag:</span><br><span class=\"line\"></span><br><span class=\"line\">    enabled: true</span><br></pre></td></tr></table></figure>\n<h1 id=\"《Go-Web》\"><a href=\"#《Go-Web》\" class=\"headerlink\" title=\"《Go Web》\"></a>《Go Web》</h1><ul>\n<li>Go PATH</li>\n<li>gin</li>\n</ul>\n","categories":["我爱学习"],"tags":["日常学习","日常"]},{"title":"每日学习笔记(2018.8.5)","url":"https://yixiaoer.github.io/2018/08/06/日常学习笔记(2018.8.5)/","content":"<p><strong>每日学习笔记</strong><br>Web学习相关内容<br>前端后端学习记录/学习笔记<br>大部分都只是所看的记录<br><em>2018.8.5</em>github上搭建博客;《Go web》</p>\n<h1 id=\"GitHub博客的各种配置\"><a href=\"#GitHub博客的各种配置\" class=\"headerlink\" title=\"GitHub博客的各种配置\"></a>GitHub博客的各种配置</h1><h2 id=\"给自己的特别提醒\"><a href=\"#给自己的特别提醒\" class=\"headerlink\" title=\"给自己的特别提醒\"></a>给自己的特别提醒</h2><ul>\n<li>冒号后面一定要带空格..</li>\n<li>markdown文档标题一级一级的来，不要跳…</li>\n</ul>\n<h2 id=\"一些问题以及解决\"><a href=\"#一些问题以及解决\" class=\"headerlink\" title=\"一些问题以及解决\"></a>一些问题以及解决</h2><ul>\n<li>标签,分类栏点进去是空的;鼠标滑过没有链接点入<br>修改layout_macro\\sidebar.swig的代码<br>参考<a href=\"https://ryanluoxu.github.io/2017/11/26/Hexo-的-Next-主题优化/\" target=\"_blank\" rel=\"noopener\">Hexo的Next主题优化</a></li>\n<li>访问量显示<br>在leancloud上注册,打开控制台创建应用<br>参考<a href=\"https://notes.wanghao.work/2015-10-21-为NexT主题添加文章阅读量统计功能.html#配置LeanCloud\" target=\"_blank\" rel=\"noopener\">访问量</a></li>\n</ul>\n<h2 id=\"未解决的问题\"><a href=\"#未解决的问题\" class=\"headerlink\" title=\"未解决的问题\"></a>未解决的问题</h2><ul>\n<li>social部分一引入就报错</li>\n<li>rss</li>\n<li>其他各种有趣配置</li>\n</ul>\n<h2 id=\"心得收获\"><a href=\"#心得收获\" class=\"headerlink\" title=\"心得收获\"></a>心得收获</h2><ul>\n<li>稳住,别心急</li>\n<li>一步一步来</li>\n<li>做好备份啊</li>\n</ul>\n<h1 id=\"《Go-Web入门》\"><a href=\"#《Go-Web入门》\" class=\"headerlink\" title=\"《Go Web入门》\"></a>《Go Web入门》</h1>","categories":["我爱学习"],"tags":["日常学习","日常"]},{"title":"每日学习笔记(2018.8.4)","url":"https://yixiaoer.github.io/2018/08/04/日常学习笔记(2018.8.4)/","content":"<p><strong>每日学习笔记</strong><br>Web学习相关内容<br>前端后端学习记录/学习笔记<br>大部分都只是所看的记录<br><em>2018.8.4</em>github上搭建博客</p>\n<h1 id=\"在-GitHub-上创建自己的博客\"><a href=\"#在-GitHub-上创建自己的博客\" class=\"headerlink\" title=\"在 GitHub 上创建自己的博客\"></a>在 GitHub 上创建自己的博客</h1><h2 id=\"安装环境配置\"><a href=\"#安装环境配置\" class=\"headerlink\" title=\"安装环境配置\"></a>安装环境配置</h2><h3 id=\"安装node-js\"><a href=\"#安装node-js\" class=\"headerlink\" title=\"安装node.js\"></a>安装node.js</h3><h3 id=\"安装hexo\"><a href=\"#安装hexo\" class=\"headerlink\" title=\"安装hexo\"></a>安装hexo</h3><h3 id=\"关联GitHub\"><a href=\"#关联GitHub\" class=\"headerlink\" title=\"关联GitHub\"></a>关联GitHub</h3><p>特别注意<strong>空格</strong></p>\n<h3 id=\"添加ssh-key到GitHub\"><a href=\"#添加ssh-key到GitHub\" class=\"headerlink\" title=\"添加ssh key到GitHub\"></a>添加ssh key到GitHub</h3><h3 id=\"博客的基本使用操作\"><a href=\"#博客的基本使用操作\" class=\"headerlink\" title=\"博客的基本使用操作\"></a>博客的基本使用操作</h3><h1 id=\"杂七杂八的点\"><a href=\"#杂七杂八的点\" class=\"headerlink\" title=\"杂七杂八的点\"></a>杂七杂八的点</h1><h2 id=\"文章底部tag栏变成图标\"><a href=\"#文章底部tag栏变成图标\" class=\"headerlink\" title=\"文章底部tag栏变成图标\"></a>文章底部tag栏变成图标</h2><p>修改模板/themes/next/layout/_macro/post.swig，搜索 rel=”tag”&gt;#，将 # 换成<i class=\"fa fa-tag\"></i></p>\n<h2 id=\"建立标签栏和分类栏\"><a href=\"#建立标签栏和分类栏\" class=\"headerlink\" title=\"建立标签栏和分类栏\"></a>建立标签栏和分类栏</h2><p>确定主配置文件中有tag_dir: tags(category_dir:categories)<br>确定主题配置文件中有tags和categories<br>在soucre文档下(或将tags换成categories)<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo new page tags</span><br></pre></td></tr></table></figure></p>\n<p>将添加的文件中的index.md中添加(或将tags换成categories)<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">type: &quot;tags&quot;</span><br><span class=\"line\">comments: false</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"阅读全文设置\"><a href=\"#阅读全文设置\" class=\"headerlink\" title=\"阅读全文设置\"></a>阅读全文设置</h3><p>在文章中&lt; !–more–&gt; 手动添加</p>\n<h2 id=\"自动摘要生成\"><a href=\"#自动摘要生成\" class=\"headerlink\" title=\"自动摘要生成\"></a>自动摘要生成</h2><p>auto_excerpt改为true</p>\n<h2 id=\"设置动态背景\"><a href=\"#设置动态背景\" class=\"headerlink\" title=\"设置动态背景\"></a>设置动态背景</h2><p>在主题配置文件中找到canvas_nest: false，把它改为canvas_nest: true</p>\n<h2 id=\"在右上角或者左上角实现fork-me-on-github\"><a href=\"#在右上角或者左上角实现fork-me-on-github\" class=\"headerlink\" title=\"在右上角或者左上角实现fork me on github\"></a>在右上角或者左上角实现fork me on github</h2><p>点击这里或者这里挑选自己喜欢的样式,并复制代码,粘贴刚才复制的代码到themes/next/layout/_layout.swig文件中(放在<div class=\"headband\"></div>的下面),并把href改为github地址</p>\n<h2 id=\"底部加上访问量\"><a href=\"#底部加上访问量\" class=\"headerlink\" title=\"底部加上访问量\"></a>底部加上访问量</h2><h2 id=\"字数统计添加\"><a href=\"#字数统计添加\" class=\"headerlink\" title=\"字数统计添加\"></a>字数统计添加</h2>","categories":["我爱学习"],"tags":["日常学习","日常"]},{"title":"关东圣地巡礼","url":"https://yixiaoer.github.io/2018/08/03/史上最强圣地巡礼,请pick你的选择/","content":"<h1 id=\"史上最强的圣地巡礼-安排上了-请pick你的选择\"><a href=\"#史上最强的圣地巡礼-安排上了-请pick你的选择\" class=\"headerlink\" title=\"史上最强的圣地巡礼(安排上了,请pick你的选择)\"></a>史上最强的圣地巡礼(安排上了,请pick你的选择)</h1><p>日本关东地区日漫日剧日影取景地巡礼计划<br>待完善…</p>\n<h2 id=\"按剧名-动漫名分类-字母序\"><a href=\"#按剧名-动漫名分类-字母序\" class=\"headerlink\" title=\"按剧名/动漫名分类(字母序)\"></a>按剧名/动漫名分类(字母序)</h2><h3 id=\"灌篮\"><a href=\"#灌篮\" class=\"headerlink\" title=\"灌篮\"></a>灌篮</h3><ul>\n<li>镰仓高校前站</li>\n</ul>\n<h3 id=\"海街\"><a href=\"#海街\" class=\"headerlink\" title=\"海街\"></a>海街</h3><ul>\n<li>江之岛</li>\n</ul>\n<h3 id=\"君名\"><a href=\"#君名\" class=\"headerlink\" title=\"君名\"></a>君名</h3><ul>\n<li>新宿须贺神社</li>\n<li>JR信浓町站前的人行天桥（多次出现的场景，泷独自在傍晚倚靠过数次，三叶在前往东京寻找泷时也在同样的位置呆过，结尾泷与奥寺的重逢，最后也在桥上道别）</li>\n<li>详见那几个很好很完备的打卡攻略</li>\n</ul>\n<h3 id=\"秒五\"><a href=\"#秒五\" class=\"headerlink\" title=\"秒五\"></a>秒五</h3><ul>\n<li>新宿车站</li>\n<li>叁宫桥站附近铁路交叉点（炸火车的地方）</li>\n<li>详见那几个很好很完备的打卡攻略</li>\n</ul>\n<h3 id=\"四谎\"><a href=\"#四谎\" class=\"headerlink\" title=\"四谎\"></a>四谎</h3><ul>\n<li>外景地主要在练马区（靠近新宿区）</li>\n<li>练马文化中心（动漫中东和hall）</li>\n<li>小平市民文化会馆（动漫中比赛地）</li>\n<li>汉堡餐厅</li>\n<li>练马区西武池袋线（动漫中的车道）</li>\n</ul>\n<h3 id=\"无头骑士\"><a href=\"#无头骑士\" class=\"headerlink\" title=\"无头骑士\"></a>无头骑士</h3><ul>\n<li>池袋的到处啊！！</li>\n</ul>\n<h3 id=\"向阳处的她\"><a href=\"#向阳处的她\" class=\"headerlink\" title=\"向阳处的她\"></a>向阳处的她</h3><ul>\n<li>江之岛</li>\n</ul>\n<h3 id=\"逃耻有用\"><a href=\"#逃耻有用\" class=\"headerlink\" title=\"逃耻有用\"></a>逃耻有用</h3><ul>\n<li>横滨市菊名站</li>\n<li>他们的小窝（神奈川県横浜市港北区篠原北2-3-8）</li>\n<li>象鼻公园</li>\n<li>山梨县大善寺</li>\n<li>伊豆修善寺</li>\n</ul>\n<h3 id=\"言叶之庭\"><a href=\"#言叶之庭\" class=\"headerlink\" title=\"言叶之庭\"></a>言叶之庭</h3><ul>\n<li>新宿御园</li>\n</ul>\n<h3 id=\"摇曳露营\"><a href=\"#摇曳露营\" class=\"headerlink\" title=\"摇曳露营\"></a>摇曳露营</h3><ul>\n<li>本栖湖</li>\n</ul>\n<h3 id=\"悠长假期\"><a href=\"#悠长假期\" class=\"headerlink\" title=\"悠长假期\"></a>悠长假期</h3><ul>\n<li>万金餐厅</li>\n<li>直接找三井生命大楼（三井生命新大橋ビル）</li>\n</ul>\n<h3 id=\"约会恋爱到底是什么呢\"><a href=\"#约会恋爱到底是什么呢\" class=\"headerlink\" title=\"约会恋爱到底是什么呢\"></a>约会恋爱到底是什么呢</h3><ul>\n<li>港见丘公园</li>\n<li>山下公园</li>\n</ul>\n<h3 id=\"to-be-continued\"><a href=\"#to-be-continued\" class=\"headerlink\" title=\"to be continued\"></a>to be continued</h3><h3 id=\"p-s-有其它什么需要安排的剧漫取景地在群里嚎一声吖！\"><a href=\"#p-s-有其它什么需要安排的剧漫取景地在群里嚎一声吖！\" class=\"headerlink\" title=\"p.s.有其它什么需要安排的剧漫取景地在群里嚎一声吖！\"></a>p.s.有其它什么需要安排的剧漫取景地在群里嚎一声吖！</h3><h2 id=\"按地区分类\"><a href=\"#按地区分类\" class=\"headerlink\" title=\"按地区分类\"></a>按地区分类</h2><h3 id=\"东京\"><a href=\"#东京\" class=\"headerlink\" title=\"东京\"></a>东京</h3><ul>\n<li><p>新宿区（太多太多在这里取景的动漫了！</p>\n<ul>\n<li><p>新宿车站小田急线</p>\n</li>\n<li><p>须贺神社（《你的名字》）</p>\n<ul>\n<li>须贺神社的楼梯！！终于都回头了！终于没有错过辣！</li>\n<li>东京新宿区四谷须贺町5，JR中央线、总武线或东京地铁丸之内线、南北线-四谷站，出站步行10分钟</li>\n</ul>\n</li>\n<li>西新宿站口和NTT DoCoMo代代木大厦（《你的名字》和《秒速五厘米》都有取景）</li>\n<li>新宿御苑（《言叶之庭》大量取景，《你的名字》中有出现）<ul>\n<li>东京都新宿区内藤町11，丸之内线-新宿御苑前站，或副都心线/都营新宿线-新宿三丁目站，出站步行5分钟</li>\n<li>9:00-16:30（16:00停止入园）</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>秋叶原（各种各种）</p>\n</li>\n<li>涉谷<ul>\n<li>那个命运的路口（各种各种各种）</li>\n<li>代代木公园（《秒速五厘米》</li>\n<li>代代木车站（《你的名字》）</li>\n</ul>\n</li>\n<li><p>池袋（《无头骑士异闻录》的各种场景啊！！）</p>\n</li>\n<li><p>东江区</p>\n<ul>\n<li>三井生命新大橋ビル（《悠长假期》）<ul>\n<li>濑名楼98年就拆了..</li>\n<li>但是濑名楼后面的三井生命，橙色的新大桥，附近大楼上的广告牌，小南和弟弟真二靠过的栏杆和河岸旁的柳树，还有男女主第一次接吻坐过的堤坝还一直在！</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>练马区</p>\n<ul>\n<li>文化中心（《四月是你的谎言》）</li>\n<li>西武池袋线</li>\n<li>汉堡餐厅（《四月是你的谎言》）<ul>\n<li>男主角的青梅竹馬椿与学长放学后约会的店</li>\n<li>味道似乎也还不错，可以打卡吃汉堡</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>离东京中心距离较远的部分区域</p>\n<ul>\n<li>小平市民文化会馆（《四月是你的谎言》）</li>\n</ul>\n</li>\n<li><p>除上面所提及的巡礼外觉得不错的地点</p>\n<ul>\n<li><p>富士电视台</p>\n</li>\n<li><p>自由女神像</p>\n</li>\n<li><p>国立博物馆</p>\n</li>\n<li><p>忠犬八公纪念像</p>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"大阪\"><a href=\"#大阪\" class=\"headerlink\" title=\"大阪\"></a>大阪</h3><ul>\n<li>大阪日本桥（关西的秋叶原）</li>\n</ul>\n<h3 id=\"镰仓\"><a href=\"#镰仓\" class=\"headerlink\" title=\"镰仓\"></a>镰仓</h3><ul>\n<li>镰仓高校前站（《灌篮高手》）<ul>\n<li>从 镰仓站购买江之电通票（可以全天无限次乘坐江之电，江之电已经在镰仓运行100多年了哇），前往灌篮高手取景地—— 镰仓高校前站，在第8站</li>\n<li>出站之后右拐，就看了命运之路口，樱木和晴子挥手的地方</li>\n<li>要拍照一定要早早到，十点前，最好9点左右，否则人超多</li>\n</ul>\n</li>\n<li>江之岛（《向阳处的她》，《海街日记》）<ul>\n<li>出站之后左转，走大约1公里，就到了《向阳处的她》树里和松本润走过的通往江之岛的桥</li>\n<li>前行的一条街道有一些小店小吃</li>\n<li>一直往上爬，在江之岛的最里面，就到了恋人の丘「龍恋の鐘」（《向阳处的她》取景）</li>\n</ul>\n</li>\n<li>文佐食堂（《海街日记》）<ul>\n<li>海街日记的拍摄地，电影中的海猫食堂</li>\n<li>可以去那里吃午饭（嗯对，还是日本拉面）</li>\n</ul>\n</li>\n<li>除上面所提及的巡礼外觉得不错的地点</li>\n<li>圆觉寺<ul>\n<li>在“北镰仓”这一站下车</li>\n<li>日本文学家活动的一大集中地</li>\n<li>湘南海岸</li>\n<li>看各种游记&amp;图感觉这里静静的，感觉这里的海边和街道都分外惬意</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"横滨\"><a href=\"#横滨\" class=\"headerlink\" title=\"横滨\"></a>横滨</h3><ul>\n<li>山下公园，港见丘公园（《约会恋爱到底是什么》）<ul>\n<li>恋爱圣地横滨港口</li>\n</ul>\n</li>\n<li>菊名站附近（《逃避虽然可耻但却有用》）<ul>\n<li>屋子就在这附近（神奈川県横浜市港北区篠原北2-3-8）</li>\n</ul>\n</li>\n<li>横滨港未来区（《逃避虽然可耻但却有用》）<ul>\n<li>日本最佳夜景之一</li>\n<li>各种地标建筑</li>\n</ul>\n</li>\n<li>除上面所提及的巡礼外觉得不错的地点<ul>\n<li>《无间双龙》、《love shuffle》、《倒数第二次恋爱》、《昼颜》、《今天不上班》等很多日剧都在这里取景（参考网址3中非常详细）</li>\n<li>港口，桥，蓝天，白云，感觉很美了</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"山梨\"><a href=\"#山梨\" class=\"headerlink\" title=\"山梨\"></a>山梨</h3><ul>\n<li>大善寺（《逃避虽然可耻但却有用》）</li>\n<li>本栖湖（《摇曳露营》）</li>\n</ul>\n<h3 id=\"…to-be-continued\"><a href=\"#…to-be-continued\" class=\"headerlink\" title=\"…to be continued\"></a>…to be continued</h3><h2 id=\"参考网址\"><a href=\"#参考网址\" class=\"headerlink\" title=\"参考网址\"></a>参考网址</h2><ul>\n<li>1⃣️<a href=\"http://www.mafengwo.cn/i/7109681.html\" target=\"_blank\" rel=\"noopener\">镰仓圣地巡礼</a></li>\n<li>2⃣️<a href=\"https://bbs.qyer.com/thread-1389162-1.html\" target=\"_blank\" rel=\"noopener\">东京 镰仓 横滨巡礼</a></li>\n<li>3⃣️<a href=\"https://travel98.com/trip/19579\" target=\"_blank\" rel=\"noopener\">日剧场景 横滨</a></li>\n<li>4⃣️<a href=\"http://blog.livedoor.jp/touyokojunrei-yokofuji3/archives/61659418.html\" target=\"_blank\" rel=\"noopener\">秒五</a>（但是..全日文，里面有地图链接可以直接参考）</li>\n<li>5⃣️<a href=\"http://blog.livedoor.jp/touyokojunrei-yokofuji3/archives/66083853.html\" target=\"_blank\" rel=\"noopener\">君名</a>（又全日文..好的我选择chrome自动翻译，这里面有地图链接可以直接参考）</li>\n<li>6⃣️[悠长假期](<a href=\"https://www.douban.com/note/637689747/]\" target=\"_blank\" rel=\"noopener\">https://www.douban.com/note/637689747/]</a></li>\n<li>7⃣️<a href=\"https://www.mafengwo.cn/i/8575270.html\" target=\"_blank\" rel=\"noopener\">一些景点&amp;美食&amp;其他参考</a></li>\n<li>8⃣️<a href=\"https://zh-tw.kikou.io/entries/165\" target=\"_blank\" rel=\"noopener\">四月是你的谎言</a></li>\n<li>9⃣️<a href=\"http://qq.mafengwo.cn/travels/info.php?id=6757088\" target=\"_blank\" rel=\"noopener\">奔跑在日剧世界</a></li>\n<li>🔟<a href=\"https://bbs.qyer.com/thread-3000414-1.html\" target=\"_blank\" rel=\"noopener\">镰仓 横滨 东京 巡礼</a></li>\n<li>1⃣️1⃣️<a href=\"https://zhuanlan.zhihu.com/p/31376571\" target=\"_blank\" rel=\"noopener\">逃耻 横滨</a>；<a href=\"http://erikasky.pixnet.net/blog/post/46874488-%5B%E6%97%A5%E5%8A%87%5D-%E9%80%83%E9%81%BF%E9%9B%96%E5%8F%AF%E6%81%A5%E4%BD%86%E6%9C%89%E7%94%A8-%E6%A8%AA%E6%B5%9C%E6%8B%8D%E6%94%9D%E5%9C%B0%E9%BB%9E%E5%B7%A1%E7%A6%AE!!\" target=\"_blank\" rel=\"noopener\">逃耻</a></li>\n<li>1⃣️2⃣️<a href=\"http://www.mafengwo.cn/gonglve/ziyouxing/81710.html\" target=\"_blank\" rel=\"noopener\">东京动漫朝圣</a></li>\n<li>1⃣️3⃣️<a href=\"https://www.google.com/maps/d/viewer?mid=1eEMtWSg0aquXVtRLnrwnZ8hVrxk&amp;ll=35.675546722502276%2C139.72549301586923&amp;z=14\" target=\"_blank\" rel=\"noopener\">你的名字 google地图版</a>（简直神器！！</li>\n<li>1⃣️4⃣️<a href=\"http://tsuinte.ru/2018/japan-trip-acg-related/\" target=\"_blank\" rel=\"noopener\">你的名字和秒速五厘米打卡详细攻略</a></li>\n</ul>\n","categories":["吃喝玩乐"],"tags":["玩乐","出行"]},{"title":"每日学习笔记(2018.8.3)","url":"https://yixiaoer.github.io/2018/08/03/日常学习笔记(2018.8.3)/","content":"<p><strong>每日学习笔记</strong><br>Web学习相关内容<br>前端后端学习记录/学习笔记<br>大部分都只是所看的记录<br><em>2018.8.3</em>看《http 权威指南》</p>\n<h1 id=\"《http-权威指南》第三章\"><a href=\"#《http-权威指南》第三章\" class=\"headerlink\" title=\"《http 权威指南》第三章\"></a>《http 权威指南》第三章</h1><p>关于报文</p>\n<h2 id=\"报文简述\"><a href=\"#报文简述\" class=\"headerlink\" title=\"报文简述\"></a>报文简述</h2><ul>\n<li>如果说HTTP是因特网的信使,那么HTTP报文就是它用来搬东西的包裹</li>\n<li>HTTP报文是在HTTP应用程序之间发送的、简单的格式化的数据块,这些数据块以一些文本形式的元信息(meta-information)开头,这些信息描述了报文的内容和含义,后面跟着可选的数据部分</li>\n<li>报文在客户端、服务器和代理之间流动,”流入”、”流出”、”上游”、”下游”都是来描述报文方向的</li>\n<li>每条报文都包含一条来自客户端的请求,或者一条来自服务器的响应</li>\n<li>所有的报文可以分为两类:请求报文(request message,向Web 服务器请求一个动作)和响应报文(response message,将请求的结果返回给客户端)</li>\n</ul>\n<h2 id=\"报文流\"><a href=\"#报文流\" class=\"headerlink\" title=\"报文流\"></a>报文流</h2><ul>\n<li>报文流入源端服务器</li>\n<li>流入(inbound)和流出(outbound)来描述事务处理(transaction )的方向</li>\n<li>报文流入源端服务器,工作完成后,会流回用户的 Agent 代理中</li>\n<li>报文向下游流动</li>\n<li>不论是请求报文还是响应报文,所有报文都会向下游(downstream)流动</li>\n<li>所有报文的发送者都在接收者的上游(upstream)</li>\n</ul>\n<h2 id=\"报文\"><a href=\"#报文\" class=\"headerlink\" title=\"报文\"></a>报文</h2><h3 id=\"报文的组成部分\"><a href=\"#报文的组成部分\" class=\"headerlink\" title=\"报文的组成部分\"></a>报文的组成部分</h3><ul>\n<li>起始行(start line)<ul>\n<li>对报文进行描述,请求报文的起始行说明了要做些什么;响应报文的起始行说明发生了什么</li>\n<li>由行分隔的ASCII文本,每行都以一个由两个字符组成的行终止序列(一个回车符ASCII码13和一个换行符ASCII码10,可以写做CRLF)作为结束</li>\n<li>所有的HTTP报文都以一个起始行作为开始</li>\n</ul>\n</li>\n<li>首部(header)<ul>\n<li>包含属性</li>\n<li>本质上而言是一些名/值对的列表</li>\n<li>由行分隔的ASCII文本,每行都以一个由两个字符组成的行终止序列(一个回车符ASCII码13和一个换行符ASCII码10,可以写做CRLF)作为结束</li>\n<li>HTTP首部字段向请求和响应报文中添加了一些附加信息</li>\n<li>首部和方法配合工作,共同决定了客户端和服务器能做什么事情</li>\n</ul>\n</li>\n<li>主体(body)<ul>\n<li>可选的、包含数据</li>\n<li>可以包含文本或二进制数据,也可以为空</li>\n<li>主体是HTTP报文的负荷,即HTTP要传输的内容<h3 id=\"报文的语法\"><a href=\"#报文的语法\" class=\"headerlink\" title=\"报文的语法\"></a>报文的语法</h3></li>\n</ul>\n</li>\n<li><p>请求和响应报文的基本报文结构相同</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">请求报文的格式</span><br><span class=\"line\">&lt;method&gt;&lt;request-URL&gt;&lt;version&gt;</span><br><span class=\"line\">&lt;header&gt;</span><br><span class=\"line\">&lt;entity-body&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">响应报文的格式</span><br><span class=\"line\">&lt;version&gt;&lt;status&gt;&lt;reason-phrase&gt;</span><br><span class=\"line\">&lt;header&gt;</span><br><span class=\"line\">&lt;entity-body&gt;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>对各部分的简要描述</p>\n<ul>\n<li>方法(method)<ul>\n<li>客户端希望服务器对资源执行的动作</li>\n<li>是一个单独的词</li>\n<li>具体方法<ul>\n<li>GET</li>\n<li>POST</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>请求URL(request-URL)<ul>\n<li>命名了所请求资源,或者URL路径组件的完整URL</li>\n<li>若直接与服务器进行对话,只要URL的路径组件是资源的绝对路径,通常不会有什么问题(服务器可以假定自己是URL的主机/端口)</li>\n</ul>\n</li>\n<li>版本(version)<ul>\n<li>报文所使用的HTTP版本,格式:HTTP/<major>.<minor></minor></major></li>\n<li>其中主要版本号(major)和次要版本号(minor)都是整数</li>\n</ul>\n</li>\n<li>状态码(status-code)<ul>\n<li>三位数字描述了请求过程中所发生的情况</li>\n<li>每个状态码的第一位数字都用于描述状态的一般类别(e.g.”成功”、”出错”等)</li>\n</ul>\n</li>\n<li>原因短语(reason-phrase)<ul>\n<li>数字状态码的可读版</li>\n<li>只对人类有意义</li>\n</ul>\n</li>\n<li>首部(header)<ul>\n<li>可以有零个或多个首部</li>\n<li>每个首部都包含一个名字,后面跟着一个冒号(:),然后是一个可选的空格,接着是一个值,最后是一个CRLF</li>\n<li>首部是由一个空格(CRLF)结束的,表示了首部列表的结束和实体主体部分的开始</li>\n<li>实体的主体部分(entity-body)15章具体描述，再来补充</li>\n<li>包含一个由任意数据组成的数据块</li>\n<li>并不是所有的报文都有实体的主体部分,有时报文只是以一个CRLF结束<h3 id=\"起始行\"><a href=\"#起始行\" class=\"headerlink\" title=\"起始行\"></a>起始行</h3></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>请求行(请求报文的起始行)<ul>\n<li>请求报文请求服务器对资源进行一些操作</li>\n<li>包含了一个方法(描述了服务器应该执行的操作)和一个请求URL(描述了要对哪个资源执行这个方法),还包含HTTP的版本(告知服务器,客户端使用的是哪种HTTP)</li>\n<li>所有字符段都由空格符分隔</li>\n</ul>\n</li>\n<li>响应行(响应报文的起始行)<ul>\n<li>响应报文承载了状态信息和操作产生的所有结果数据,将其返回给客户端</li>\n<li>包含了响应报文使用的HTTP版本、数字状态码以及描述操作状态的文本形式的原因短语</li>\n<li>所有字段都由空格符进行分割<h3 id=\"方法\"><a href=\"#方法\" class=\"headerlink\" title=\"方法\"></a>方法</h3></li>\n</ul>\n</li>\n<li>请求的起始行以方法作为开始,方法用来告知服务器要做些什么</li>\n<li>安全方法<ul>\n<li>HTTP定义的一组被称为安全方法的方法</li>\n<li>使用安全方法的目的是当使用可能引发某一动作的不安全方法时,允许HTTP应用程序开发者通知用户</li>\n</ul>\n</li>\n<li>一组常用的HTTP方法<ul>\n<li>GET<ul>\n<li>最常用的方法,通常用于请求服务器发送某个资源</li>\n<li>从服务器中获取一份文档,不包含主体</li>\n</ul>\n</li>\n<li>HEAD<ul>\n<li>和GET方法很类似,但服务器在响应中只返回首部,不会返回实体的主体部分</li>\n<li>允许客户端在未获取实际资源的情况下,对资源的首部进行检查</li>\n<li>从服务器获取文档的首部,不包含主体</li>\n<li>常用于测试超链接的有效性,是否可以访问,以及最近是否更新,通过查看响应中的状态码看某个对象是否存在,查看首部来看资源是否被修改,在不获取资源的情况下了解其情况(e.g.判断其类型)</li>\n</ul>\n</li>\n<li>PUT<ul>\n<li>与GET从服务器读取文档相反, PUT方法会向服务器写入文档</li>\n<li>将请求的主体部分储存在服务器上,包含主体</li>\n<li>让服务器用请求的主体部分来创建一个由所请求的URL命名的新文档,或者如果那个URL已经存在的话,就用这个主题来代替</li>\n<li>因为PUT允许用户对内容进行修改,很多 Web 服务器都要求在执行PUT前用密码登录</li>\n</ul>\n</li>\n<li>POST<ul>\n<li>起初是用来向服务器输入数据的,实际上会用它来支持HTML的表单</li>\n<li>向服务器发送需要处理的数据,包含主体</li>\n<li>支持HTML表单时,表单中填好的数据通常会被送给服务器,然后由服务器将其发送到它要去的地方</li>\n</ul>\n</li>\n<li>TRACE<ul>\n<li>客户端发送一个请求时可能要穿过防火墙、代理、网关或其他一些应用程序,中间每个节点都可能会修改原始HTTP请求,TRACE方法允许客户端在最终将请求发送给服务器时看看它变成了什么样子</li>\n<li>对可能经过代理服务器传送到服务器上的报文进行追踪,不包含主体</li>\n</ul>\n</li>\n<li>OPTIONS<ul>\n<li>请求WEB服务器告知其支持的各种功能</li>\n<li>决定可以在服务器上执行哪些方法,不包含主体</li>\n<li>为客户端应用程序提供了一种手段,使其不用实际访问那些资源就能判定访问各种资源的最优方式</li>\n</ul>\n</li>\n<li>DELETE<ul>\n<li>请服务器删除URL所制定的资源</li>\n<li>从服务器上删除一份文档,不包含主体</li>\n<li>客户端应用程序无法保证删除操作一定会被执行</li>\n</ul>\n</li>\n<li>扩展方法<ul>\n<li>HTTP被设计成字段可扩展,扩展放大指的是没有在HTTP/1.1规范中定义的方法</li>\n<li>即使服务器实现了所有这些方法,这些方法的使用很可能也是受限的,这些限制通常都是在服务器的配置中进行设置的,因此会随着站点和服务器的不同而有所不同<h3 id=\"状态码\"><a href=\"#状态码\" class=\"headerlink\" title=\"状态码\"></a>状态码</h3></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>位于相应的起始行中,告诉客户端发生了什么事情</li>\n<li>状态码分类<ul>\n<li>1xx 信息性状态码</li>\n<li>2xx成功状态码</li>\n<li>3xx重定向状态码</li>\n<li>4xx客户端错误状态码</li>\n<li>5xx服务器错误状态码</li>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/HTTP/Status\" target=\"_blank\" rel=\"noopener\">https://developer.mozilla.org/en-US/docs/Web/HTTP/Status</a></li>\n<li><a href=\"https://blog.csdn.net/diandianxiyu_geek/article/details/50373195\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/diandianxiyu_geek/article/details/50373195</a></li>\n</ul>\n</li>\n<li>原因短语<ul>\n<li>响应起始行中的最后一个组件,为状态码提供了文本形式的解释</li>\n<li>原因短语与状态码是成对出现的,原因短语是状态码的可读版本</li>\n</ul>\n</li>\n<li>版本号<ul>\n<li>以HTTP/x.y的形式出现在请求和响应报文的起始中</li>\n<li>为HTTP应用程序提供了一种将自己所遵循的协议版本告知对方的方式</li>\n<li>使用版本号的目的是为使用HTTP的应用程序提供一种线索,以便互相了解对方的能力和报文格式</li>\n<li>版本号说明了应用程序支持的最高HTTP版本</li>\n<li>版本中点左右的每个数字都会被当作一个单独的数字来处理,在比较HTTP版本时每个数字都必须进行单独比较,以确定哪个版本更高(e.g.HTTP/2.22比HTTP/2.3的版本要高,因为22大于3)<h3 id=\"首部\"><a href=\"#首部\" class=\"headerlink\" title=\"首部\"></a>首部</h3></li>\n</ul>\n</li>\n<li>通用首部<ul>\n<li>既可以出现在请求报文中,也可以出现在响应报文中</li>\n<li>可以在客户端、服务器和其他应用程序之间提供一些非常有用的通用功能<ul>\n<li>通用信息性首部<ul>\n<li>Connection 允许客户端和服务器指定与请求/响应连接有关的选项</li>\n<li>Date 提供日期和时间标志,说明报文是何时创建的</li>\n<li>MIME-Version 给出了发送端使用的MIME版本</li>\n<li>Trailer 如果报文采用了分块传输编码(chunked transfer encoding)方式,就可以用这个首部列出位于报文拖挂(trailer)部分的首部集合</li>\n<li>Transfer-Encoding 告知接收端为了保证报文的可靠传输,对报文采用了什么编码方式</li>\n<li>Updating 给出了发送端可能想要”升级使用的新版本或协议</li>\n<li>Via 显示了报文经过的中间节点(代理、网关)</li>\n</ul>\n</li>\n<li>通用缓存首部<ul>\n<li>Cache-Control 用于随报文传送缓存指示</li>\n<li>Pragma 另一种随报文传送指示的方式,但并不专用于缓存(其确切语义未得到较好的定义,任何情况下Cache-Control的使用都优于它)</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>请求首部<ul>\n<li>是请求报文特有的,为服务器提供更多有关请求的信息(e.g.客户端希望接受什么类型的数据)</li>\n<li>请求的信息性首部<ul>\n<li>Client-ip 提供了运行客户端的机器的IP地址</li>\n<li>From 提供了客户端用户的 Email 地址</li>\n<li>Host 给出了接受请求的服务器的主机名和端口号</li>\n<li>Referer 提供了包含当前请求URI的文档的URL</li>\n<li>UA-Color 提供了与客户端显示器的显示颜色有关的信息</li>\n<li>UA-CPU 给出了客户端CPU的类型或制造商</li>\n<li>UA-Disp 提供了与客户端显示器(屏幕)能力有关的信息</li>\n<li>UA-OS 给出了运行在客户端机器上的操作系统名称及版本</li>\n<li>UA-Pixels 提供了客户端显示器地像素信息</li>\n<li>User-Agent 将发起请求的应用程序名称告知服务器</li>\n</ul>\n</li>\n<li>Accept首部<ul>\n<li>为客户端提供了一种将其喜好和能力告知服务器的方式</li>\n<li>一些Accept 首部<ul>\n<li>Accept 告诉服务器嫩个够发送那些媒体类型</li>\n<li>Accept-Charset 告诉服务器能够发送哪些字符集</li>\n<li>Accept-Encoding 告诉服务器能够发送哪些编码方式</li>\n<li>Accept-Language 告诉服务器能够发送哪些语言</li>\n<li>TE 告诉服务器可以使用哪些扩展传输编码</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>条件请求首部<ul>\n<li>有时客户端希望为请求加上某些限制,通过条件请求首部,客户端可以为请求加上这种限制,要求服务器在对请求进行响应之前,确保某个条件为真</li>\n<li>一些条件响应首部<ul>\n<li>Expect 允许客户端列出某请求所要求的服务器行为</li>\n<li>If-Match 如果实体标记与文档当前的实体标记相匹配,就获取这份文档</li>\n<li>If-Modified-Since 除非在某个指定的日期之后资源被修改过,否则就限制这个请求</li>\n<li>If-None-Match 如果提供的实体标记与当前的文档的实体标记不相符,就获取文档</li>\n<li>If-Range 允许对文档的某个范围进行条件请求</li>\n<li>If-Unmodified-Since 除非在某个指定日期之后资源没有被修改过,否则就限制这个请求</li>\n<li>Range 如果服务器支持范围请求,就请求资源的指定范围</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>安全请求首部<ul>\n<li>客户端在获取特定的资源之前,先对自身进行认证,使事务稍微安全一些</li>\n<li>一些安全请求首部<ul>\n<li>Authorization 包含了客户端提供给服务器,以便对其自身进行认证的数据</li>\n<li>Cookie 客户端用它向服务器传送一个令牌,并非真正的安全首部,但确实隐含了安全功能</li>\n<li>Cookie2用来说明请求端支持的 cookie 版本</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>代理请求首部<ul>\n<li>协助网络代理更好工作</li>\n<li>一些代理请求首部<ul>\n<li>Max-Forward 在通往源端服务器的路径上,将请求转发给其他代理或网关的最大次数(与TRACE方法一同使用)</li>\n<li>Proxy-Authorization 与Authorization 首部相同,但这个首部是在与代理进行认证时使用的</li>\n<li>Proxy-Connection 与Connection首部相同,但这个首部是在与代理建立连接时使用的</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>响应首部<ul>\n<li>响应报文的首部集,为客户端提供更多有关响应的信息</li>\n<li>响应的信息性首部<ul>\n<li>Age (从最初创建开始)响应持续时间</li>\n<li>Public 服务器为其资源支持的请求方法列表</li>\n<li>Retry-After 如果资源不可用,在此日期或时间重试</li>\n<li>Server 服务器应用程序软件的名称和版本</li>\n<li>Title 对HTML文档来说,就是HTML文档的源端给出的标题</li>\n<li>Waring 比原因短语中更详细一些的警告报文</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>协商首部<ul>\n<li>传递与可协商资源有关的信息</li>\n<li>一些协商首部<ul>\n<li>Accept-Range 对此资源来说,服务器可接受的范围类型</li>\n<li>Vary 服务器查看的其他首部的列表,可能会使响应发生变化;这是一个首部列表,服务器会根据这些首部的内容,挑选出最适合的资源版本发送给客户端</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>安全响应首部<ul>\n<li>HTTP的质询/响应认证机制的响应侧</li>\n<li>一些安全响应首部<ul>\n<li>Proxy-Authenticate 来自代理的对客户端的质询列表</li>\n<li>Set-Cookie 不是真正的安全首部,但因含有安全功能;可以在客户端设置一个令牌,以便服务器对客户端进行标识</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>实体首部<ul>\n<li>对应实体主体部分的首部</li>\n<li>描述主体的长度和内容,或者资源自身</li>\n<li>实体的信息性首部<ul>\n<li>Allow 列出了可以对此实体执行的请求方法</li>\n<li>Location 告知客户端实体实际上位于何处;用于将接受断定想到资源的(可能是新的)位置(URL)上去</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>内容首部<ul>\n<li>提供了与实体内容有关的信息</li>\n<li>一些内容首部<ul>\n<li>Content-Base 解析主体中的相对URL时使用的基础URL</li>\n<li>Content-Encoding 对主体执行的任意编码方式</li>\n<li>Content-Language 解析主体时最适宜使用的自然语言</li>\n<li>Content-Length 主体的长度或尺寸</li>\n<li>Content-Location 资源实际所处的位置</li>\n<li>Content-MD5 主体的MD5校验和</li>\n<li>Content-Range 在整个资源中此实体表示的字节范围</li>\n<li>Content-Type 这个主题的对象类型</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>实体缓存首部<ul>\n<li>通用的缓存首部说明了如何或什么时候进行缓存,实体的缓存首部提供了与被缓存实体有关的信息</li>\n<li>一些实体缓存首部<ul>\n<li>ETag 与此实体相关的实体标记</li>\n<li>Expires 实体不再有效,要从原始的源端再次获取此实体的日期和时间</li>\n<li>Last-Modified 这个实体最后一次被修改的日期和时间</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>扩展首部<ul>\n<li>规范中没有定义的新首部</li>\n<li>由开发者创建</li>\n<li>简单的语法，名字后面跟着冒号(:),然后跟上可选的空格,再跟上字值段,最后是一个CRLF</li>\n<li>首部延续行</li>\n<li>将长的首部行分为多行可以提高可读性,多出来的每行前面至少要有一个空格或制表符(tab)<h3 id=\"实体\"><a href=\"#实体\" class=\"headerlink\" title=\"实体\"></a>实体</h3></li>\n</ul>\n</li>\n</ul>\n","categories":["我爱学习"],"tags":["日常学习","日常"]},{"title":"每日学习笔记(2018.8.2)","url":"https://yixiaoer.github.io/2018/08/02/每日学习笔记(2018.8.2)/","content":"<p><strong>每日学习笔记</strong><br>Web学习相关内容<br>前端后端学习记录/学习笔记<br>大部分都只是所看的记录<br><em>2018.8.2</em>看《http 权威指南》;前端学习</p>\n<h1 id=\"《http-权威指南》第二章\"><a href=\"#《http-权威指南》第二章\" class=\"headerlink\" title=\"《http 权威指南》第二章\"></a>《http 权威指南》第二章</h1><h2 id=\"URL的语法\"><a href=\"#URL的语法\" class=\"headerlink\" title=\"URL的语法\"></a>URL的语法</h2><h3 id=\"简述\"><a href=\"#简述\" class=\"headerlink\" title=\"简述\"></a>简述</h3><ul>\n<li>通过描述资源的位置来识别资源</li>\n<li>是URI的子集(URI的子集还包括URN,通过名字来识别资源)</li>\n<li>URL提供了一种统一的资源命名方式大多数URL方案的URL语法都建立在这个由9部分构成的通用格式上:<blockquote>\n<p><em><scheme>://<user>:<password>@<host>:<port>/<path></path>;<params>?<query>#<frag>/</frag></query></params></port></host></password></user></scheme></em><br>几乎没有哪个URL中包含了所有这些组件,URL中最重要的3个部分是方案(scheme)、主机(host)和路径(path)</p>\n</blockquote>\n<h3 id=\"URL的各种组件\"><a href=\"#URL的各种组件\" class=\"headerlink\" title=\"URL的各种组件\"></a>URL的各种组件</h3></li>\n<li>方案<ul>\n<li>规定如何访问指定资源的主要标识符,告诉负责解析URL的应用应该<strong><strong>使用什么协议</strong></strong>(e.g. http)</li>\n<li>可以告知 Web 客户端怎样访问资源,可以指向因特网上的任意资源或个人的Email 账户,或者通过其他协议(e.g. FTP协议)访问各种文件,或者从流视频服务器上下载电影</li>\n<li>大小写无关(e.g.HTTP与http是等价的)</li>\n</ul>\n</li>\n<li>主机与端口<ul>\n<li>对应了服务器的位置(e.g.  <a href=\"http://www.google.com),告知\" target=\"_blank\" rel=\"noopener\">www.google.com),告知</a> Web 客户端资源位于何处</li>\n<li>主机组件标识了因特网上能够访问资源的宿主机器,可以用主机名或者IP地址来表示</li>\n<li>端口组件标识了服务器正在监听的网络端口,对下层使用了TCP协议的HTTP来说,默认端口号为80</li>\n</ul>\n</li>\n<li>用户名和密码<ul>\n<li>用户组件是某些方案访问资源是需要的用户名,默认值为匿名</li>\n<li>密码组件是用户名后面可能要包含的密码,中间由冒号(:)分隔,默认值为<email 地址=\"\"></email></li>\n</ul>\n</li>\n<li>路径<ul>\n<li>说明了资源位于服务器的什么地方</li>\n<li>通常很像一个分级的文件系统路径</li>\n<li>可以用字符”/“将HTTP URL的路径组件划分为一些路径段,每个路径段都有自己的参数(param)组件</li>\n</ul>\n</li>\n<li>参数<ul>\n<li>由字符”;”将其与URL的其余部分(以及各名值对)分隔开来</li>\n<li>为应用程序提供了访问资源所需的所有附加信息</li>\n<li>查询字符串</li>\n<li>查询(query)组件在字符”?”的右边</li>\n<li>名值对之间用字符”&amp;”分隔</li>\n</ul>\n</li>\n<li>片段<ul>\n<li>有些资源类型(e.g.HTML)除资源级外,还可以做进一步的划分,为了引用部分资源或资源的一个片段,URL支持使用片段(frag)组件来表示一个资源内部的片段</li>\n<li>片段在URL的右边,前面有一个”#”字符</li>\n<li>服务器处理的是整个对象,URL片段仅由客户端使用</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"URL快捷方式\"><a href=\"#URL快捷方式\" class=\"headerlink\" title=\"URL快捷方式\"></a>URL快捷方式</h2><h3 id=\"相对URL\"><a href=\"#相对URL\" class=\"headerlink\" title=\"相对URL\"></a>相对URL</h3><ul>\n<li>URL有两种方式:<strong>相对的</strong>和<strong>绝对的</strong>,绝对URL中包含有访问资源所需的全部信息</li>\n<li>相对URL是不完整的,是URL的一种便捷缩略记法,要从相对URL中获取访问资源所需的全部信息,就必须相对于另一个,被称为其基础(base)的URL进行解析<ul>\n<li>转换处理相对URL<ul>\n<li>找到基础URL</li>\n<li>基础URL是作为相对URL的参考点使用的</li>\n<li>基础URL的来源<ul>\n<li>在资源中显式提供(显式地指定,直接标记)</li>\n<li>封装资源的基础URL</li>\n<li>没有基础URL<ul>\n<li>解析相对引用</li>\n<li>将相对URL和基础URL划分成组件段</li>\n<li>将相对URL转换成绝对URL</li>\n<li>自动拓展URL</li>\n<li>用户不需要输入完整的URL,浏览器会自动拓展</li>\n<li>两种方式(主机名拓展和历史拓展)</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"URL字符集\"><a href=\"#URL字符集\" class=\"headerlink\" title=\"URL字符集\"></a>URL字符集</h3><h1 id=\"前端学习\"><a href=\"#前端学习\" class=\"headerlink\" title=\"前端学习\"></a>前端学习</h1><h2 id=\"Tips\"><a href=\"#Tips\" class=\"headerlink\" title=\"Tips\"></a>Tips</h2><ul>\n<li>去掉按钮按下之后的小蓝框{outline:none;}</li>\n<li>去掉文本框右下的小三角{resize:none;}</li>\n<li>js实现双击后更改文本内容</li>\n<li>dom操作添加button(这类)时,create的element是input,然后再xxx.type=”button”;</li>\n<li>text上不能接入onclick等事件,但文本框可以</li>\n</ul>\n<h4 id=\"今日感想\"><a href=\"#今日感想\" class=\"headerlink\" title=\"今日感想\"></a>今日感想</h4><p>我求我自己别懒了！</p>\n<p>我求我自己别逃避了！</p>\n<p>我求我自己别找借口了！</p>\n","categories":["我爱学习"],"tags":["日常学习","日常"]},{"title":"每日学习笔记(2018.8.1)","url":"https://yixiaoer.github.io/2018/08/01/每日学习笔记(2018.8.1)/","content":"<p><strong>每日学习笔记</strong><br>Web学习相关内容<br>前端后端学习记录/学习笔记<br>大部分都只是所看的记录<br><em>2018.8.1</em>看《http 权威指南》;前端学习</p>\n<h1 id=\"《http权威指南》第一章\"><a href=\"#《http权威指南》第一章\" class=\"headerlink\" title=\"《http权威指南》第一章\"></a>《http权威指南》第一章</h1><h2 id=\"Tips\"><a href=\"#Tips\" class=\"headerlink\" title=\"Tips\"></a>Tips</h2><ul>\n<li>Web内容都是存储在服务器上,浏览一个页面时,浏览器会向服务器发送一条http请求,服务器会去寻找所期望的对象,如果成功就将对象、对象类型、对象长度及其他一些信息放在HTTP响应中发送给客户端</li>\n<li>Web 服务器是Web 资源的宿主,Web 资源是 Web 内容的源头,所有能够提供 Web 内容的东西都是 Web 资源</li>\n</ul>\n<h2 id=\"MIME类型\"><a href=\"#MIME类型\" class=\"headerlink\" title=\"MIME类型\"></a>MIME类型</h2><ul>\n<li>Multipurpose Internet Mail Extension,多用途因特网邮件拓展</li>\n<li>MIME类型是一种文本标记,大小写不敏感,一般习惯用小写</li>\n<li>通用结构：type/subtype<ul>\n<li>由类型与子类型两个字符串中间用<code>&#39;/&#39;</code>分隔而组成</li>\n<li>不允许空格存在<em>type</em> 表示可以被分为复数子类的独立类型(eg.text,img,audio,video…)</li>\n<li><em>subtype</em>表示细分后的每个类型</li>\n<li>Multipart类型是复合文件的一种表达方式,可用于HTML表单从浏览器发送信息给服务器</li>\n</ul>\n</li>\n<li>MDN中文文档:<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Basics_of_HTTP/MIME_types\" target=\"_blank\" rel=\"noopener\">https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Basics_of_HTTP/MIME_types</a><br>MDN英文文档:<a href=\"https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types\" target=\"_blank\" rel=\"noopener\">https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types</a></li>\n</ul>\n<h2 id=\"HTTP事务\"><a href=\"#HTTP事务\" class=\"headerlink\" title=\"HTTP事务\"></a>HTTP事务</h2><ul>\n<li>一个HTTP事务由一条请求命令(客户端发往服务器)和一个响应结果(服务器发回客户端)组成,这种通信是通过名为HTTP报文(HTTP message)的格式化数据块进行的<h3 id=\"HTTP方法\"><a href=\"#HTTP方法\" class=\"headerlink\" title=\"HTTP方法\"></a>HTTP方法</h3></li>\n<li>HTTP支持几种不同的请求命令,这些命令被称为HTTP方法(HTTP method),每条HTTP请求都会包含一个方法，这个方法会告诉服务器执行的动作</li>\n<li>HTTP响应报文返回时携带<h3 id=\"HTTP状态码\"><a href=\"#HTTP状态码\" class=\"headerlink\" title=\"HTTP状态码\"></a>HTTP状态码</h3><h3 id=\"HTTP报文\"><a href=\"#HTTP报文\" class=\"headerlink\" title=\"HTTP报文\"></a>HTTP报文</h3></li>\n<li>纯文本</li>\n<li>包括起始行、首部字段、主体</li>\n</ul>\n<h2 id=\"TCP-IP\"><a href=\"#TCP-IP\" class=\"headerlink\" title=\"TCP/IP\"></a>TCP/IP</h2><blockquote>\n<p>应用层（HTTP）</p>\n<p>传输层（TCP）</p>\n<p>网络层（IP）</p>\n<p>数据链路层（网络特有的链路接口）</p>\n<p>物理层（物理网络硬件）</p>\n</blockquote>\n<h3 id=\"关于TCP\"><a href=\"#关于TCP\" class=\"headerlink\" title=\"关于TCP\"></a>关于TCP</h3><ul>\n<li>HTTP是个应用层协议,不负责网络通信的具体细节,联网的细节由TCP提供<ul>\n<li>无差错的数据传输</li>\n<li>接续传输(按发送顺序到达)</li>\n<li>未分段的数据流</li>\n</ul>\n</li>\n<li>Transmission Control Protocol,传输控制协议</li>\n<li>基于文本</li>\n<li>在HTTP客户端向服务器发送报文之前,需要用网际协议(Internet Protocal,IP)地址和端口号在客户端和服务器之间建立一条TCP/IP连接<ul>\n<li>浏览器从URL中解析出服务器的主机名</li>\n<li>浏览器将服务器的主机名转换成服务器的IP地址</li>\n<li>浏览器将端口号(如果存在)从URL中解析出来</li>\n<li>浏览器建立一条与Web 服务器的TCP连接</li>\n<li>浏览器向服务器发送一条HTTP请求报文</li>\n<li>服务器向浏览器回送一条HTTP响应报文</li>\n<li>关闭连接,浏览器显示文档</li>\n</ul>\n</li>\n<li>Telnet<ul>\n<li>提供双向、以文字字符串为主的命令行接口交互功能,可将键盘连接到某个目标TCP端口,并将此端口的输出回送到显示屏上</li>\n<li>TCP/IP协议族的其中之一</li>\n<li>Internet远程登录服务的标准协议和主要方式</li>\n<li>常用于服务器的远程控制(远程终端会话),可供用户在本地主机运行远程主机上的工作,几乎可以连接所有的TCP服务器</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"Web-的结构组件\"><a href=\"#Web-的结构组件\" class=\"headerlink\" title=\"Web 的结构组件\"></a>Web 的结构组件</h2><h3 id=\"代理\"><a href=\"#代理\" class=\"headerlink\" title=\"代理\"></a>代理</h3><ul>\n<li>位于客户端和服务器之间的HTTP中间实体,接受所有客户端的HTTP请求,并将这些请求转发给服务器(可能会对请求进行修改后转发)</li>\n<li>出于安全考虑,代理通常会作为转发所有 Web 流量的可信任中间节点使用</li>\n<li>可以对请求和响应进行一些过滤<h3 id=\"缓存-cache\"><a href=\"#缓存-cache\" class=\"headerlink\" title=\"缓存(cache)\"></a>缓存(cache)</h3></li>\n<li>一种特殊的HTTP代理服务器,可以将经过代理传送的常用文档复制保存起来,下一个请求同一文档的客户端就可以享受缓存的私有副本提供的服务</li>\n<li>下载缓存文档速度更快<h3 id=\"网关-gateway\"><a href=\"#网关-gateway\" class=\"headerlink\" title=\"网关(gateway)\"></a>网关(gateway)</h3></li>\n<li>一种特殊的服务器,作为其他服务器的中间实体使用</li>\n<li>通常用于将HTTP流量转换成其他的协议</li>\n<li>网关接受请求时就好像自己是资源的源端服务器一样,客户端可能并不知道自己正在与一个网关进行通信<h3 id=\"隧道-tunnel\"><a href=\"#隧道-tunnel\" class=\"headerlink\" title=\"隧道(tunnel )\"></a>隧道(tunnel )</h3></li>\n<li>隧道是建立起来之后会在两条连接之间对原始数据进行盲转发的HTTP应用程序</li>\n<li>通常用来在一条或多条HTTP连接上转发非HTTP数据,转发时不会窥探数据</li>\n<li>常见途径是通过HTTP连接承载加密的安全套接字层(SSL,Secure Sockets Layer)流量,这样SSL流量就可以穿过只允许Web流量通过的防火墙<h3 id=\"Agent-代理\"><a href=\"#Agent-代理\" class=\"headerlink\" title=\"Agent 代理\"></a>Agent 代理</h3></li>\n<li>用户 Agent 代理是代表用户发起HTTP请求的客户端程序</li>\n<li>所有发布Web请求的应用程序都是HTTP agent 代理</li>\n</ul>\n<h1 id=\"前端部分学习\"><a href=\"#前端部分学习\" class=\"headerlink\" title=\"前端部分学习\"></a>前端部分学习</h1><ul>\n<li>在js中插入css</li>\n<li>将css用外部文件使用</li>\n<li>导航栏用标签属性完成</li>\n</ul>\n","categories":["我爱学习"],"tags":["日常学习","日常"]},{"title":"亲自尝试的美味之肉末茄子","url":"https://yixiaoer.github.io/2017/12/20/亲自尝试的美味/","content":"<p>一道菜的记录之肉末茄子</p>\n<p><em>给记忆力不太好的自己的记录，同时安利</em></p>\n<h1 id=\"碎碎念\"><a href=\"#碎碎念\" class=\"headerlink\" title=\"碎碎念\"></a>碎碎念</h1><p>关于茄子做好了真的是非常好吃了，但是一直都做得一般般</p>\n<p>也看过一些菜谱，感觉最重要的一点还是炒茄子的时候不能放水</p>\n<p>但是自己还是把握不好</p>\n<p>而且加盐腌制什么的真的好麻烦还要设置闹钟…</p>\n<p>于是多次尝试…</p>\n<h1 id=\"话不多说\"><a href=\"#话不多说\" class=\"headerlink\" title=\"话不多说\"></a>话不多说</h1><h2 id=\"食材\"><a href=\"#食材\" class=\"headerlink\" title=\"食材\"></a>食材</h2><ul>\n<li>茄子(4个)</li>\n<li>洋葱(1个)</li>\n<li>蒜(切碎,4瓣)</li>\n<li>姜(切碎,小块)</li>\n<li>葱(切碎)</li>\n<li>蚝油(1勺)</li>\n<li>盐(适量)</li>\n<li>白砂糖(适量)</li>\n</ul>\n<h2 id=\"行动\"><a href=\"#行动\" class=\"headerlink\" title=\"行动\"></a>行动</h2><ul>\n<li>洋葱、蒜、姜、葱切好放在一起</li>\n</ul>\n<p>P.S.洋葱和葱尖先留一部分在旁边,最后加入不做调味作为颜色更好看的调色</p>\n<ul>\n<li><p>腌制好的肉切成肉末</p>\n</li>\n<li><p>茄子斜切成条</p>\n</li>\n<li><p>大火加入适量油,待油热加入肉末翻炒,肉末颜色变化,则将肉末盛起并快速放好事先准备好的洋葱姜葱</p>\n</li>\n<li><p>爆炒调味待蒜香欲出,盛起</p>\n</li>\n<li><p>加入茄子,翻炒,并按压,反复,待达到某种微妙的平衡点,加入肉末和事先炒过的调料,并继续翻炒</p>\n</li>\n<li><p>加入蚝油1勺,盐适量,最后加入糖,关火,再拌匀起锅</p>\n</li>\n</ul>\n<h2 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明\"></a>说明</h2><ul>\n<li>蚝油可以再爱一万年</li>\n<li>最后加点糖提味很棒</li>\n<li>油的量很微妙</li>\n<li>蒜香！</li>\n</ul>\n","categories":["吃喝玩乐"],"tags":["吃喝","菜谱"]},{"title":"一个汉口小朋友对楚河汉街美食的不成熟探索","url":"https://yixiaoer.github.io/2017/11/24/关于楚河汉街一块的打卡过／打算打卡的好吃的/","content":"<p>关于楚河汉街一块的打卡过／打算打卡的好吃的</p>\n<h1 id=\"为什么要记录\"><a href=\"#为什么要记录\" class=\"headerlink\" title=\"为什么要记录\"></a>为什么要记录</h1><p>一天之内，有两位武汉的小阔爱问我楚河汉街那边有什么好吃的？？？</p>\n<p>喵喵喵？？？我也是汉口人啊！</p>\n<p>仔细想了一下那边吃过的海星的店，明白了，来安排一下（全文各处其实几乎都由ww带路！她是真正的美食雷达吖！</p>\n<h1 id=\"话不多说\"><a href=\"#话不多说\" class=\"headerlink\" title=\"话不多说\"></a>话不多说</h1><h2 id=\"偏西式\"><a href=\"#偏西式\" class=\"headerlink\" title=\"偏西式\"></a>偏西式</h2><ul>\n<li>偏爱<ul>\n<li>西式餐以及面包甜点等</li>\n<li>各种东西都还不错,面包带走吃也是个不错的选择</li>\n</ul>\n</li>\n<li>lady 7<ul>\n<li>西式，甜点，吐司，蛋糕</li>\n<li>主打吐司，里面有冰淇凌很棒</li>\n<li>店内少女心十足，去吃过好几次</li>\n<li>但是最近去吃感觉<strong>一般般</strong>了(是的感觉已经不爱了)</li>\n</ul>\n</li>\n<li>祐禾Uhealth<ul>\n<li>面包(把面包放入这个分类也是很强行的）</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"不偏西式-嗷-这是什么鬼分类\"><a href=\"#不偏西式-嗷-这是什么鬼分类\" class=\"headerlink\" title=\"不偏西式(嗷,这是什么鬼分类..)\"></a>不偏西式(嗷,这是什么鬼分类..)</h2><ul>\n<li>骉骉火锅<ul>\n<li>火锅</li>\n<li>配冰粉感觉味道很赞</li>\n<li>感觉好辣，点微辣让我辣到头疼(可能和个人辣级有关..)</li>\n</ul>\n</li>\n<li>辣员外火锅<ul>\n<li>火锅</li>\n<li>牛蛙毛肚什么的都不错</li>\n</ul>\n</li>\n<li>一笼简单点<ul>\n<li>港式</li>\n<li>店面超级少女！各种粉红色！！！</li>\n<li>味道也海星，但不算特别好吃的，但是因为好看就要去啊！</li>\n<li>两个妹子去吃感觉没点很多竟然就觉得好撑..</li>\n</ul>\n</li>\n<li>翠华餐厅<ul>\n<li>港式</li>\n<li>ww推荐</li>\n</ul>\n</li>\n<li>稻香<ul>\n<li>港式</li>\n<li>当年说着要去吃榴莲酥,把别人说动了我却还没去吃..</li>\n</ul>\n</li>\n<li>赤熊<ul>\n<li>日式</li>\n<li>简餐什么的还阔以啦</li>\n<li>汉街上&amp;凯德1818都有</li>\n</ul>\n</li>\n<li>犇牛道<ul>\n<li>日式烤肉</li>\n<li>疯狂打 call！！</li>\n<li>这家店偶尔有折扣，趁折扣去疯狂吃肉叭！</li>\n</ul>\n</li>\n<li>小川料理<ul>\n<li>日式</li>\n<li>ww推荐！</li>\n</ul>\n</li>\n<li>炉边炭情<ul>\n<li>烤肉</li>\n<li>海星!</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li>to be continued</li>\n</ul>\n","categories":["吃喝玩乐"],"tags":["发现美食","吃喝"]},{"title":"search","url":"https://yixiaoer.github.io/search/index.html","content":"","categories":[],"tags":[]},{"title":"category","url":"https://yixiaoer.github.io/category/index.html","content":"","categories":[],"tags":[]},{"title":"about","url":"https://yixiaoer.github.io/about/index.html","content":"","categories":[],"tags":[]},{"title":"tag","url":"https://yixiaoer.github.io/tag/index.html","content":"","categories":[],"tags":[]}]